#include <time.h>

#include <boost/algorithm/string.hpp>
#include <boost/filesystem/fstream.hpp>
#include <boost/program_options.hpp>
#include <boost/regex.hpp>

#include <elle/log/CompositeLogger.hh>
#include <elle/log/TextLogger.hh>
#include <elle/Error.hh>
#include <elle/Exit.hh>
#include <elle/finally.hh>
#include <elle/With.hh>
#include <elle/cast.hh>
#include <elle/format/base64url.hh>
#include <elle/json/exceptions.hh>
#include <elle/network/Interface.hh>
#include <elle/os/environ.hh>
#include <elle/system/user_paths.hh>
#include <elle/system/username.hh>

#include <das/model.hh>
#include <das/serializer.hh>

#include <reactor/http/Request.hh>
#include <reactor/network/rdv-socket.hh>
#include <reactor/network/rdv-socket.hh>
#include <reactor/network/buffer.hh>
#include <reactor/network/resolve.hh>

#include <cryptography/hash.hh>
#include <cryptography/rsa/KeyPair.hh>

#include <reactor/filesystem.hh>
#include <reactor/network/upnp.hh>
#include <reactor/scheduler.hh>
#include <reactor/thread.hh>

#ifndef INFINIT_WINDOWS
# include <crash_reporting/CrashReporter.hh>
#endif

#include <infinit/utility.hh>
#include <infinit/credentials/AWSCredentials.hh>
#include <infinit/credentials/OAuthCredentials.hh>
#include <infinit/filesystem/filesystem.hh>
#include <infinit/model/doughnut/Local.hh>
#include <infinit/model/doughnut/Doughnut.hh>
#include <infinit/model/doughnut/consensus/Paxos.hh>
#include <infinit/overlay/kelips/Kelips.hh>
#include <infinit/storage/Async.hh>
#include <infinit/storage/Cache.hh>

#include "version.hh"

extern std::string program;

class QName
  : public std::string
{
public:
  QName()
    : QName("/")
  {}

  QName(std::string qname)
    : std::string(std::move(qname))
  {
    if (this->find("/") == std::string::npos)
      ELLE_ABORT("invalid qualified name: %s", *this);
  }

  QName(std::string const& qualifier, std::string const& name)
    : std::string(elle::sprintf("%s/%s", qualifier, name))
  {}

  std::string
  unqualified(std::string const& qualifier) const
  {
    if (this->qualifier() == qualifier)
      return this->name();
    else
      return *this;
  }

  std::string
  qualifier() const
  {
    auto pos = this->find("/");
    ELLE_ASSERT_NEQ(pos, std::string::npos);
    return this->substr(0, pos);
  }

  std::string
  name() const
  {
    auto pos = this->find("/");
    ELLE_ASSERT_NEQ(pos, std::string::npos);
    return this->substr(pos + 1);
  }
};

#define COMMAND(name)                                           \
  static                                                        \
  void                                                          \
  name(boost::program_options::variables_map const& args,       \
       boost::signals2::signal<void()>& killed)                 \

#define NO_PRIVATE_KEY "user \"%s\" has no private key"

inline
bool
show_hidden_options()
{
#ifndef INFINIT_PRODUCTION_BUILD
  return true;
#endif
  return !elle::os::getenv("INFINIT_SHOW_HIDDEN_OPTIONS", "").empty();
}

inline
std::string
beyond(bool help = false)
{
  if (help && !elle::os::inenv("INFINIT_BEYOND"))
    return "the Hub";

  auto static const res = elle::os::getenv("INFINIT_BEYOND", "${beyond_host}");
  return res;
}

static std::unique_ptr<std::ofstream> critical_log_stream;

class CommandLineError
  : public elle::Error
{
public:
  template <typename ... Args>
  CommandLineError(Args&& ... args)
    : elle::Error(elle::sprintf(std::forward<Args>(args)...))
  {}
};

struct BeyondError
  : public elle::Error
{
  BeyondError(std::string const& error,
              std::string const& reason,
              boost::optional<std::string> const& name = boost::none)
    : elle::Error(reason)
    , _error(error)
    , _name(name)
  {
    ELLE_TRACE("error: %s", *this);
  }

  BeyondError(elle::serialization::SerializerIn& s)
    : BeyondError(s.deserialize<std::string>("error"),
                  s.deserialize<std::string>("reason"),
                  s.deserialize<boost::optional<std::string>>("name"))
  {}

  std::string
  name_opt() const
  {
    return _name ? *_name : "NAME";
  }

  ELLE_ATTRIBUTE_R(std::string, error);
  ELLE_ATTRIBUTE_R(boost::optional<std::string>, name);
};

class MissingResource
  : public elle::Error
{
public:
  template <typename ... Args>
  MissingResource(Args&& ... args)
    : elle::Error(std::forward<Args>(args)...)
  {}
};

class MissingLocalResource
  : public MissingResource
{
public:
  template <typename ... Args>
  MissingLocalResource(Args&& ... args)
    : MissingResource(std::forward<Args>(args)...)
  {}
};

class ResourceGone
  : public MissingResource
{
public:
  template <typename ... Args>
  ResourceGone(Args&& ... args)
    : MissingResource(std::forward<Args>(args)...)
  {}
};

class ResourceProtected
  : public elle::Error
{
public:
  template <typename ... Args>
  ResourceProtected(Args&& ... args)
    : elle::Error(std::forward<Args>(args)...)
  {}
};

class ResourceAlreadyFetched
  : public elle::Error
{
public:
  template <typename ... Args>
  ResourceAlreadyFetched(Args&& ... args)
    : elle::Error(std::forward<Args>(args)...)
  {}
};

class Redirected
  : public elle::Error
{
public:
  Redirected(std::string const& url)
    : elle::Error(
      elle::sprintf("%s caused an unsupported redirection", url))
  {}
};

inline
void
not_found(std::string const& name,
          std::string const& type)
{
  std::cerr << elle::sprintf("%s %s not found on %s, ensure it has been pushed",
                             type, name, beyond(true))
            << std::endl;
}

inline
void
forbidden(std::string const& name,
          std::string const& type)
{
  std::cerr << elle::sprintf("access to %s %s forbidden on %s", type,
                             name, beyond(true))
            << std::endl;
}

inline
void
gone(std::string const& type)
{
  std::cerr << elle::sprintf("%s is no longer available on %s", type,
                             beyond(true))
            << std::endl;
}

struct Storages
{
  int64_t usage;
  boost::optional<int64_t> capacity;
};

DAS_MODEL(Storages, (usage, capacity), DasStorages);
DAS_MODEL_DEFAULT(Storages, DasStorages);
DAS_MODEL_SERIALIZE(Storages);

extern bool script_mode;
extern boost::optional<std::string> _as_user;

inline
void
report(std::string const& msg)
{
  if (!script_mode)
  {
    elle::printf("%s%s.", (char)toupper(msg[0]), msg.substr(1));
    std::cout << std::endl;
  }
}

inline
void
report_action(std::string const& action,
              std::string const& type,
              std::string const& name,
              boost::optional<std::string> where_ = {})
{
  std::string where = where_ ? elle::sprintf("%s ", where_.get()) : "";
  report(elle::sprintf("%s%s %s \"\%s\"", where, action, type, name));
}

inline
void
report_created(std::string const& type, std::string const& name)
{
  report_action("created", type, name, std::string("locally"));
}

inline
void
report_updated(std::string const& type, std::string const& name)
{
  report_action("updated", type, name, std::string("locally"));
}

inline
void
report_imported(std::string const& type, std::string const& name)
{
  report_action("imported", type, name);
}

inline
void
report_action_output(std::ostream& output,
                     std::string const& action,
                     std::string const& type,
                     std::string const& name)
{
  if (&output != &std::cout)
    report_action(action, type, name);
}

inline
void
report_exported(std::ostream& output,
                std::string const& type,
                std::string const& name)
{
  report_action_output(output, "exported", type, name);
}

struct Mode
{
  static
  std::string
  upper_fchar(std::string const& str)
  {
    if (str.length() == 0)
      return str;
    return elle::sprintf("%s%s", (char)toupper(str[0]), str.substr(1));
  }

  class OptionDescription
    : public boost::program_options::option_description
  {
  typedef std::pair<std::string, boost::program_options::value_semantic const*>
    DeprecatedAliasPair;
  public:
    OptionDescription(
        std::string const& name,
        boost::program_options::value_semantic const* s,
        std::string const& description,
        std::vector<DeprecatedAliasPair> const& deprecated_aliases_ = {})
      : boost::program_options::option_description(
          name.c_str(), s, upper_fchar(description).c_str())
    {
      using boost::program_options::option_description;
      for (auto const& deprecated: deprecated_aliases_)
      {
        deprecated_options.push_back(
          boost::shared_ptr<option_description>(
            new option_description(
              deprecated.first.c_str(), deprecated.second,
              elle::sprintf("Use \"--%s\" instead", name).c_str())));
      }
    }

    std::vector<boost::shared_ptr<boost::program_options::option_description>>
      deprecated_options;
  };

  class OptionsDescription;

  class OptionsDescriptionEasyInit
    : boost::program_options::options_description_easy_init
  {
  public:
    OptionsDescriptionEasyInit(OptionsDescription* owner)
      : boost::program_options::options_description_easy_init(owner)
      , my_owner(owner)
    {}

    OptionsDescriptionEasyInit&
    operator()(std::string const& name,
               std::string const& description)
    {
      boost::shared_ptr<boost::program_options::option_description> d(
        new boost::program_options::option_description(
          name.c_str(),
          new boost::program_options::untyped_value(true),
          upper_fchar(description).c_str()));

      my_owner->add(d);
      return *this;
    }

    OptionsDescriptionEasyInit&
    operator()(std::string const& name,
               boost::program_options::value_semantic const* s,
               std::string const& description)
    {
      boost::shared_ptr<boost::program_options::option_description> d(
        new boost::program_options::option_description(
          name.c_str(),
          s,
          upper_fchar(description).c_str()));
      my_owner->add(d);
      return *this;
    }

    private:
      boost::program_options::options_description* my_owner;
  };

  class OptionsDescription
    : public boost::program_options::options_description
  {
  public:
    OptionsDescription(std::string const& desc)
      : boost::program_options::options_description(desc)
    {}

    OptionsDescriptionEasyInit
    add_options()
    {
      return OptionsDescriptionEasyInit(this);
    }
  };

  typedef
    std::function<void (boost::program_options::variables_map const&,
                        boost::signals2::signal<void ()>&)> Action;
  typedef std::vector<OptionDescription> Options;
  typedef std::vector<OptionsDescription> OptionsVector;

  Mode(std::string name_,
       std::string description_,
       Action action_,
       std::string help = {},
       Options options = {},
       OptionsVector extra_options = {},
       Options hidden_options = {},
       OptionsVector hidden_extra_options = {})
    : name(std::move(name_))
    , description(upper_fchar(description_))
    , action(std::move(action_))
    , help_complement(upper_fchar(help))
    , options(this->description)
    , visible_options(this->description)
  {
    namespace po = boost::program_options;
    Mode::OptionsDescription mode_options(
      elle::sprintf("%s options", upper_fchar(this->name)));
    po::options_description deprecated("Deprecated options");
    int deprecated_count = 0;
    for (auto const& option: options)
    {
      mode_options.add(
        boost::shared_ptr<po::option_description>
        (new po::option_description(std::move(option))));
      for (auto const& old: option.deprecated_options)
      {
        deprecated_count++;
        deprecated.add(old);
      }
    }
    this->_add_options(mode_options);
    if (deprecated_count)
      this->_add_options(deprecated, false);
    for (auto const& extra: extra_options)
      this->_add_options(extra);
    po::options_description hidden("Hidden options");
    for (auto const& option: hidden_options)
    {
      hidden.add(
        boost::shared_ptr<boost::program_options::option_description>
        (new boost::program_options::option_description(std::move(option))));
    }
    this->_add_options(hidden, false);
    for (auto const& extra: hidden_extra_options)
      this->_add_options(extra, false);
  }

  void
  _add_options(boost::program_options::options_description const& options,
               bool visible_in_production = true)
  {
    if (options.options().size() == 0)
      return;
    this->options.add(options);
    if (visible_in_production || show_hidden_options())
      this->visible_options.add(options);
  }

  void
  help(std::ostream& output) const
  {
    output << "Usage: " << program
           << " --" << this->name;
    if (!this->help_complement.empty())
      output << " " << this->help_complement;
    output << " [OPTIONS...]" << std::endl;
    output << std::endl;
    output << this->visible_options;
    output << std::endl;
  }

  std::string name;
  std::string description;
  Action action;
  std::string help_complement;
  boost::program_options::options_description options;
  boost::program_options::options_description visible_options;
};
typedef std::vector<Mode> Modes;

inline
boost::program_options::variables_map
parse_args(boost::program_options::options_description const& options,
           std::vector<std::string> const& args,
           std::string const& positional_arg)
{
  namespace po = boost::program_options;
  auto parser = po::command_line_parser(args);
  auto style = static_cast<int>(po::command_line_style::default_style);
  style &= ~po::command_line_style::allow_guessing;
  parser.style(style);
  po::positional_options_description p;
  p.add(positional_arg.c_str(), -1);
  parser.options(options).positional(p);
  po::variables_map res;
  auto parsed = parser.run();
  po::store(parsed, res);
  po::notify(res);
  return res;
}

static
bool
is_hidden_file(boost::filesystem::path const& path)
{
  if (path.filename().string().front() == '.' ||
      path.filename().string().back() == '~')
  {
    return true;
  }
  return false;
}

namespace infinit
{
  struct User;
}

template <typename T>
void
beyond_push(std::string const& where,
            std::string const& type,
            std::string const& name,
            T const& o,
            infinit::User const& self,
            bool report = true,
            bool beyond_error = false, // FIXME: Remove when migration done.
            bool update = false);

static
Mode::OptionDescription option_cache(
  "cache", boost::program_options::value<bool>()->implicit_value(true, "true"),
  "enable caching with default values");
static
Mode::OptionDescription option_cache_ram_size(
  "cache-ram-size", boost::program_options::value<int>(),
  "maximum RAM block cache size in bytes\n(default: 64 MB)",
  {{"cache-size", boost::program_options::value<int>()}});
static
Mode::OptionDescription option_cache_ram_ttl(
  "cache-ram-ttl", boost::program_options::value<int>(),
  "RAM block cache time-to-live in seconds\n(default: 5 minutes)",
  {{"cache-ttl", boost::program_options::value<int>()}});
static
Mode::OptionDescription option_cache_ram_invalidation(
  "cache-ram-invalidation", boost::program_options::value<int>(),
  "RAM block cache invalidation time in seconds\n(default: 15 seconds)",
  {{"cache-invalidation", boost::program_options::value<int>()}});
static
Mode::OptionDescription option_cache_disk_size(
  "cache-disk-size", boost::program_options::value<uint64_t>(),
  "size of disk cache for immutable data in bytes\n(default: 512 MB)",
  {{"disk-cache-size", boost::program_options::value<uint64_t>()}});
static
Mode::OptionDescription option_port_file(
  "port-file", boost::program_options::value<std::string>(),
  "write node listening port to file");
static
Mode::OptionDescription option_endpoint_file(
  "endpoints-file", boost::program_options::value<std::string>(),
  "write node listening endpoints to file\n(format: host:port\\n)");
static
Mode::OptionDescription option_port(
  "port", boost::program_options::value<int>(),
  "outbound port to use");
static
Mode::OptionDescription option_disable_mac_utf8(
  "disable-utf-8-conversion", boost::program_options::bool_switch(),
  "disable FUSE conversion of UTF-8 to native format");


class CommandLineSerializer
  : public elle::serialization::SerializerIn
{
public:
  typedef elle::serialization::SerializerIn Super;
  CommandLineSerializer(boost::program_options::variables_map const& vm)
    : Super(ELLE_SFINAE_INSTANCE(std::istream), false)
    , _variables(vm)
  {}

protected:
  boost::program_options::variables_map const& _variables;

  virtual
  void
  _serialize_array(std::string const& name,
                   int size, // -1 for in(), array size for out()
                   std::function<void ()> const& f)
  {
    ELLE_ABORT("not handled");
  }

  virtual
  void
  _serialize(std::string const& name, int64_t& v)
  {
    ELLE_ABORT("not handled");
  }

  virtual
  void
  _serialize(std::string const& name, uint64_t& v)
  {
    ELLE_ABORT("not handled");
  }

  virtual
  void
  _serialize(std::string const& name, int32_t& v)
  {
    ELLE_ABORT("not handled");
  }

  virtual
  void
  _serialize(std::string const& name, uint32_t& v)
  {
    ELLE_ABORT("not handled");
  }

  virtual
  void
  _serialize(std::string const& name, int8_t& v)
  {
    ELLE_ABORT("not handled");
  }

  virtual
  void
  _serialize(std::string const& name, uint8_t& v)
  {
    ELLE_ABORT("not handled");
  }

  virtual
  void
  _serialize(std::string const& name, double& v)
  {
    ELLE_ABORT("not handled");
  }

  virtual
  void
  _serialize(std::string const& name, bool& v)
  {
    ELLE_ABORT("not handled");
  }

  virtual
  void
  _serialize(std::string const& name, std::string& v)
  {
    v = this->_get(name).as<std::string>();
  }

  virtual
  void
  _serialize(std::string const& name, elle::Buffer& v)
  {
    ELLE_ABORT("not handled");
  }

  virtual
  void
  _serialize(std::string const& name, boost::posix_time::ptime& v)
  {
    ELLE_ABORT("not handled");
  }

  virtual
  void
  _serialize_option(std::string const& name,
                    bool present,
                    std::function<void ()> const& f)
  {
    if (this->_variables.count(name))
      f();
  }

private:
  boost::program_options::variable_value const&
  _get(std::string const& name)
  {
    auto count = this->_variables.count(name);
    if (!count)
      throw elle::Error(elle::sprintf("missing required \"%s\" option", name));
    if (count > 1)
      throw elle::Error(elle::sprintf("duplicate \"%s\" option", name));
    return this->_variables[name];
  }
};

template <typename T>
boost::optional<T>
check_deprecated(boost::program_options::variables_map const& vm,
                 Mode::OptionDescription const& option)
{
  for (auto const& deprecated: option.deprecated_options)
  {
    if (vm.count(deprecated->long_name()))
    {
      std::cerr << "WARNING: option \"--" << deprecated->long_name()
                << "\" is deprecated "
                << "use \"--" << option.long_name() << "\" instead."
                << std::endl;
      return vm[deprecated->long_name()].as<T>();
    }
  }
  return boost::none;
}

template <typename T = std::string>
boost::optional<T>
optional(boost::program_options::variables_map const& vm,
         std::string const& name)
{
  if (vm.count(name))
    return vm[name].as<T>();
  else
    return {};
}

template <bool>
boost::optional<bool>
optional(boost::program_options::variables_map const& vm,
         std::string const& name)
{
  if (vm.count(name))
    return vm[name].empty() || vm[name].as<bool>();
  return {};
}

template <typename T = std::string>
boost::optional<T>
optional(boost::program_options::variables_map const& vm,
         Mode::OptionDescription const& option)
{
  auto deprecated = check_deprecated<T>(vm, option);
  if (deprecated)
    return deprecated;
  return optional<T>(vm, option.long_name());
}

template <typename T = std::string>
T
mandatory(boost::program_options::variables_map const& vm,
          std::string const& name,
          std::string const& desc)
{
  if (!vm.count(name))
  {
    throw CommandLineError(
      elle::sprintf("%s unspecified (use --%s)", desc, name));
  }
  return vm[name].as<T>();
}

template <typename T = std::string>
T
mandatory(boost::program_options::variables_map const& vm,
          Mode::OptionDescription const& option,
          std::string const& desc)
{
  auto deprecated = check_deprecated<T>(vm, option);
  if (deprecated)
    return deprecated.get();
  return mandatory<T>(vm, option.long_name(), desc);
}

template <typename T = std::string>
T
mandatory(boost::program_options::variables_map const& vm,
          std::string const& name)
{
  return mandatory<T>(vm, name, name);
}

template <typename T = std::string>
T
mandatory(boost::program_options::variables_map const& vm,
          Mode::OptionDescription const& option)
{
  auto deprecated = check_deprecated<T>(vm, option);
  if (deprecated)
    return deprecated.get();
  return mandatory<T>(vm, option.long_name());
}

template <>
inline
std::vector<std::string>
mandatory<std::vector<std::string>>(
  boost::program_options::variables_map const& vm,
  std::string const& name,
  std::string const& desc)
{
  if (!vm.count(name))
  {
    throw CommandLineError(
      elle::sprintf("%s unspecified (use --%s [value ...])", desc, name));
  }
  return vm[name].as<std::vector<std::string>>();
}

inline
bool
flag(boost::program_options::variables_map const& vm,
     std::string const& name)
{
  return vm.count(name) && vm[name].as<bool>();
}

inline
bool
flag(boost::program_options::variables_map const& vm,
     Mode::OptionDescription const& option)
{
  auto deprecated = check_deprecated<bool>(vm, option);
  if (deprecated)
    return deprecated.get();
  return flag(vm, option.long_name());
}

inline
boost::optional<bool>
optional_aliased_flag(boost::program_options::variables_map const& vm,
                      std::vector<std::string> const& aliases)
{
  for (auto const& alias: aliases)
    if (vm.count(alias))
      return vm[alias].as<bool>();
  return {};
}

inline
bool
aliased_flag(boost::program_options::variables_map const& vm,
             std::vector<std::string> const& aliases)
{
  for (auto const& alias: aliases)
    if (vm.count(alias) && vm[alias].as<bool>())
      return true;
  return false;
}

inline
bool
exclusive_flag(boost::program_options::variables_map const& vm,
               std::vector<std::string> const& flags)
{
  int count = 0;
  for (auto const& f: flags)
    count += (flag(vm, f) ? 1 : 0);
  return (count == 1);
}

template<typename T>
T
beyond_fetch(std::string const& type,
             std::string const& name);

namespace infinit
{
  extern boost::optional<elle::Version> compatibility_version;
  static const std::string invalid_name(
    "name (%s) must only contain lower case alphanumeric and - . _ "
    "characters but not start with the . character");

  typedef infinit::AWSCredentials AWSCredentials;
  typedef infinit::Credentials Credentials;
  typedef infinit::OAuthCredentials OAuthCredentials;

  typedef infinit::model::doughnut::Passport Passport;

  inline
  void
  check_name(std::string const& name, bool no_slash = false)
  {
    std::string test_name;
    auto slash_pos = name.find_first_of("/");
    if (no_slash && slash_pos != std::string::npos)
      throw CommandLineError(elle::sprintf(invalid_name, name));
    if (slash_pos == std::string::npos)
      test_name = name;
    else
      test_name = name.substr(slash_pos + 1);
    static const boost::regex allowed("${name_regex}");
    boost::smatch str_matches;
    if (!boost::regex_match(test_name, str_matches, allowed))
      throw CommandLineError(elle::sprintf(invalid_name, test_name));
  }

  inline
  void
  check_broken_locale()
  {
    try
    {
      std::locale locale("");
    }
    catch (std::exception const& e)
    {
      ELLE_WARN(
        "Something is wrong with your locale settings, overriding: %s",
        e.what());
      elle::os::setenv("LC_ALL", "C", 1);
    }
  }

  int
  main(std::string desc,
       Modes const& modes,
       int argc,
       char** argv,
       boost::optional<std::string> positional_arg = {},
       boost::optional<bool> disable_as_arg = {},
       boost::optional<Modes> hidden_modes = {});

  struct User
    : public elle::Printable
  {
    User(std::string const& name,
         cryptography::rsa::KeyPair const& keys,
         boost::optional<std::string> email = {},
         boost::optional<std::string> fullname = {},
         boost::optional<std::string> ldap_dn = {})
      : name(name)
      , public_key(keys.K())
      , private_key(keys.k())
      , email(email)
      , fullname(fullname)
      , password_hash()
      , ldap_dn(ldap_dn)
    {
      check_name(this->name, true);
    }

    User(elle::serialization::SerializerIn& s)
      : name(s.deserialize<std::string>("name"))
      , public_key(s.deserialize<cryptography::rsa::PublicKey>("public_key"))
      , private_key(s.deserialize<boost::optional<
                      cryptography::rsa::PrivateKey>>("private_key"))
      , email(s.deserialize<boost::optional<std::string>>("email"))
      , fullname(s.deserialize<boost::optional<std::string>>("fullname"))
      , password_hash()
      , ldap_dn(s.deserialize<boost::optional<std::string>>("ldap_dn"))
    {
      check_name(this->name, true);
    }

    infinit::cryptography::rsa::KeyPair
    keypair() const
    {
      if (!this->private_key)
      {
        throw elle::Error(elle::sprintf(NO_PRIVATE_KEY, this->name));
      }
      return infinit::cryptography::rsa::KeyPair(this->public_key,
                                                 this->private_key.get());
    }

    void
    serialize(elle::serialization::Serializer& s)
    {
      s.serialize("email", this->email);
      s.serialize("fullname", this->fullname);
      s.serialize("avatar", this->avatar_path);
      s.serialize("name", this->name);
      s.serialize("password_hash", this->password_hash);
      s.serialize("private_key", this->private_key);
      s.serialize("public_key", this->public_key);
      s.serialize("ldap_dn", this->ldap_dn);
    }

    static
    std::string
    uid(cryptography::rsa::PublicKey const& key)
    {
      auto serial = cryptography::rsa::publickey::der::encode(key);
      auto hash = cryptography::hash(serial, cryptography::Oneway::sha256);
      return elle::format::base64url::encode(hash).string().substr(0, 8);
    }

    std::string
    uid() const
    {
      return uid(this->public_key);
    }

    bool
    operator ==(User const& user) const
    {
      return this->name == user.name &&
        this->public_key == user.public_key;
    }

    void
    print(std::ostream& out) const override
    {
      out << "User(" << this->name << ": public";
      if (this->private_key)
        out << "/private keys";
      else
        out << " key only";
      out << ")";
    }

    std::string name;
    cryptography::rsa::PublicKey public_key;
    boost::optional<cryptography::rsa::PrivateKey> private_key;
    // Hub.
    boost::optional<std::string> email;
    boost::optional<std::string> fullname;
    boost::optional<std::string> avatar_path;
    boost::optional<std::string> password_hash;
    boost::optional<std::string> password;
    boost::optional<std::string> ldap_dn;
  };

  struct Network
    : public elle::Printable
  {
    Network(std::string name, std::unique_ptr<model::ModelConfig> model)
      : name(std::move(name))
      , model(std::move(model))
    {
      check_name(this->name);
    }

    Network(elle::serialization::SerializerIn& s)
    {
      this->serialize(s);
      check_name(this->name);
    }

    void
    serialize(elle::serialization::Serializer& s)
    {
      s.serialize("name", this->name);
      s.serialize("model", this->model);
    }

    model::doughnut::Configuration*
    dht() const
    {
      return static_cast<model::doughnut::Configuration*>(this->model.get());
    }

    bool
    user_linked(infinit::User const& user) const
    {
      if (this->model == nullptr)
        return false;
      // Compare passport's public key and user public key.
      return this->dht()->passport.user() == user.public_key;
    }

    void
    ensure_allowed(infinit::User const& user,
                   std::string const& action,
                   std::string const& resource = "network") const
    {
      if (!this->user_linked(user))
        throw elle::Error(
          elle::sprintf("You cannot %s this %s as %s",
                        action, resource, user.name));
    }


    std::unique_ptr<model::doughnut::Doughnut>
    run(User const& user,
        std::vector<infinit::model::Endpoints> const& hosts = {},
        bool client = false,
        bool cache = false,
        boost::optional<int> cache_size = {},
        boost::optional<int> cache_ttl = {},
        boost::optional<int> cache_invalidation = {},
        bool async_writes = false,
        boost::optional<uint64_t> disk_cache_size = {},
        boost::optional<elle::Version> version = {},
        boost::optional<int> port = {})
    {
      ELLE_LOG("client version: %s", version_describe);
      ELLE_LOG("network endpoints: %s", hosts);
      return this->dht()->make(
        hosts,
        client,
        this->cache_dir(user),
        async_writes,
        cache,
        cache_size,
        cache_ttl
          ? std::chrono::seconds(cache_ttl.get())
          : boost::optional<std::chrono::seconds>(),
        cache_invalidation
          ? std::chrono::seconds(cache_invalidation.get())
          : boost::optional<std::chrono::seconds>(),
        disk_cache_size,
        std::move(version),
        std::move(port));
    }

    inline
    void
    notify_storage(infinit::User const& user,
                   infinit::model::Address const& node_id)
    {
      ELLE_TRACE_SCOPE("push storage stats to %s", beyond());
      try
      {
        auto url = elle::sprintf(
          "networks/%s/stat/%s/%s", name, user.name, node_id);
        auto storage = this->dht()->storage->make();
        Storages s{storage->usage(), storage->capacity()};
        beyond_push(
          url, "storage usage", name, std::move(s), user, false);
      }
      catch (elle::Error const& e)
      {
        ELLE_WARN("Error notifying storage size change: %s", e);
      }
    }

    boost::filesystem::path
    cache_dir(User const& user) const
    {
      // "/cache" and "/async" are added by Doughnut.
      auto old_dir = xdg_state_home() / "cache" / this->name;
      auto new_dir = xdg_state_home() / "cache" / user.name / this->name;
      create_directories(new_dir / "async");
      if (boost::filesystem::exists(old_dir / "async") &&
          !boost::filesystem::is_empty(old_dir / "async"))
      {
        for (boost::filesystem::recursive_directory_iterator it(old_dir / "async");
             it != boost::filesystem::recursive_directory_iterator();
             ++it)
        {
          if (is_regular_file(it->status()) && !is_hidden_file(it->path()))
          {
            boost::filesystem::copy_file(
              it->path(),
              new_dir / "async" / it->path().filename());
          }
        }
        boost::filesystem::remove_all(old_dir / "async");
      }
      if (boost::filesystem::exists(old_dir / "cache") &&
          !boost::filesystem::is_empty(old_dir / "cache"))
      {
        ELLE_WARN("old cache location (\"%s/cache\") is being emptied in favor "
                  "of the new cache location (\"%s/cache\")",
                  old_dir.string(), new_dir.string());
        boost::filesystem::remove_all(old_dir / "cache");
      }
      return new_dir;
    }

    void
    print(std::ostream& out) const override
    {
      out << "Network(" << this->name << ")";
    }

    std::string name;
    std::unique_ptr<model::ModelConfig> model;
  };

  struct NetworkDescriptor
  {
    NetworkDescriptor(
      std::string name_,
      std::unique_ptr<model::doughnut::consensus::Configuration> consensus_,
      std::unique_ptr<overlay::Configuration> overlay_,
      cryptography::rsa::PublicKey owner_,
      elle::Version version_,
      model::doughnut::AdminKeys admin_keys_)
      : name(std::move(name_))
      , consensus(std::move(consensus_))
      , overlay(std::move(overlay_))
      , owner(std::move(owner_))
      , version(std::move(version_))
      , admin_keys(std::move(admin_keys_))
    {
      check_name(this->name);
    }

    NetworkDescriptor(elle::serialization::SerializerIn& s)
      : name(s.deserialize<std::string>("name"))
      , consensus(s.deserialize<std::unique_ptr<
                  model::doughnut::consensus::Configuration>>("consensus"))
      , overlay(s.deserialize<std::unique_ptr<overlay::Configuration>>
                ("overlay"))
      , owner(s.deserialize<cryptography::rsa::PublicKey>("owner"))
      , version()
    {
      try
      {
        version = s.deserialize<elle::Version>("version");
      }
      catch (elle::serialization::Error const&)
      {
        version = elle::Version(0, 3, 0);
      }
      try
      {
        s.serialize("admin_keys", this->admin_keys);
      }
      catch (elle::serialization::Error const&)
      {
      }
      check_name(this->name);
    }

    NetworkDescriptor(Network&& network)
      : name(std::move(network.name))
      , consensus(std::move(network.dht()->consensus))
      , overlay(std::move(network.dht()->overlay))
      , owner(std::move(*network.dht()->owner))
      , version(std::move(network.dht()->version))
      , admin_keys(std::move(network.dht()->admin_keys))
    {
      check_name(this->name);
    }

    NetworkDescriptor(NetworkDescriptor const& desc)
      : name(desc.name)
      , consensus(desc.consensus->clone())
      , overlay(desc.overlay->clone())
      , owner(desc.owner)
      , version(desc.version)
      , admin_keys(desc.admin_keys)
    {}

    void
    serialize(elle::serialization::Serializer& s)
    {
      s.serialize("name", this->name);
      s.serialize("consensus", this->consensus);
      s.serialize("overlay", this->overlay);
      s.serialize("owner", this->owner);
      try
      {
        s.serialize("version", this->version);
      }
      catch (elle::serialization::Error const&)
      {
        // Oldest versions did not specify compatibility version.
        this->version = elle::Version(0, 3, 0);
      }
      try
      {
        s.serialize("admin_keys", this->admin_keys);
      }
      catch (elle::serialization::Error const&)
      {
      }
    }

    std::string name;
    std::unique_ptr<model::doughnut::consensus::Configuration> consensus;
    std::unique_ptr<overlay::Configuration> overlay;
    cryptography::rsa::PublicKey owner;
    elle::Version version;
    model::doughnut::AdminKeys admin_keys;
  };


  struct MountOptions
  {
    MountOptions();
    void to_commandline(std::vector<std::string>& arguments,
                        std::unordered_map<std::string, std::string>& env) const;
    void merge(boost::program_options::variables_map const& args);
    void merge(MountOptions const& other);
    boost::optional<std::string> hub_url;
    boost::optional<std::string> rdv;
    boost::optional<std::vector<std::string>> fuse_options;
    boost::optional<std::string> as;
    boost::optional<bool> fetch;
    boost::optional<bool> push;
    boost::optional<bool> cache;
    boost::optional<bool> async;
    boost::optional<bool> readonly;
    boost::optional<int> cache_ram_size;
    boost::optional<int> cache_ram_ttl;
    boost::optional<int> cache_ram_invalidation;
    boost::optional<uint64_t> cache_disk_size;
    boost::optional<std::string> mountpoint;
    boost::optional<std::vector<std::string>> peers;
    typedef infinit::serialization_tag serialization_tag;
  };

  inline
  MountOptions::MountOptions()
  {}

  template<typename T>
  void merge(T& a, const T& b)
  {
    if (b)
      a = b.get();
  }

  template<typename T>
  void merge(boost::optional<std::vector<T>>& a,
             boost::optional<std::vector<T>> const& b)
  {
    if (b)
    {
      if (!a)
        a = std::vector<T>();
      a.get().insert(a.get().end(), b.get().begin(), b.get().end());
    }
  }
  inline
  void
  MountOptions::merge(MountOptions const& b)
  {
    infinit::merge(hub_url, b.hub_url);
    infinit::merge(rdv, b.rdv);
    infinit::merge(fuse_options, b.fuse_options);
    infinit::merge(as, b.as);
    infinit::merge(fetch, b.fetch);
    infinit::merge(push, b.push);
    infinit::merge(cache, b.cache);
    infinit::merge(async, b.async);
    infinit::merge(readonly, b.readonly);
    infinit::merge(cache_ram_size, b.cache_ram_size);
    infinit::merge(cache_ram_ttl, b.cache_ram_ttl);
    infinit::merge(cache_ram_invalidation, b.cache_ram_invalidation);
    infinit::merge(cache_disk_size, b.cache_disk_size);
    infinit::merge(mountpoint, b.mountpoint);
    infinit::merge(peers, b.peers);
  }

  inline
  void
  MountOptions::merge(boost::program_options::variables_map const& args)
  {
    infinit::merge(this->fuse_options,
                   optional<std::vector<std::string>>(args, "fuse-option"));
    infinit::merge(this->peers,
                   optional<std::vector<std::string>>(args, "peer"));
    infinit::merge(this->mountpoint, optional(args, "mountpoint"));
    // FIXME: Why user and as?
    infinit::merge(this->as, optional(args, "as"));
    infinit::merge(this->as, optional(args, "user"));
    infinit::merge(this->readonly, optional<bool>(args, "readonly"));
    infinit::merge(this->fetch, optional_aliased_flag(args, {
      "fetch-endpoints", "fetch", "publish"}));
    infinit::merge(this->push, optional_aliased_flag(args, {
      "push-endpoints", "push", "publish"}));
    infinit::merge(this->cache, optional<bool>(args, option_cache));
    infinit::merge(this->async, optional<bool>(args, "async"));
    infinit::merge(this->cache_ram_size,
                   optional<int>(args, option_cache_ram_size));
    infinit::merge(this->cache_ram_ttl,
                   optional<int>(args, option_cache_ram_ttl));
    infinit::merge(this->cache_ram_invalidation,
                   optional<int>(args, option_cache_ram_invalidation));
    infinit::merge(this->cache_disk_size,
                   optional<uint64_t>(args, option_cache_disk_size));
  }

  inline
  void
  MountOptions::to_commandline(std::vector<std::string>& arguments,
                               std::unordered_map<std::string, std::string>& env) const
  {
    if (rdv)
      env.insert(std::make_pair("INFINIT_RDV", rdv.get()));
    if (hub_url)
      env.insert(std::make_pair("INFINIT_BEYOND", hub_url.get()));
    if (fuse_options)
      for (auto const& fo: fuse_options.get())
      {
        arguments.push_back("--fuse-option");
        arguments.push_back(fo);
      }
    if (peers)
      for (auto const& fo: peers.get())
      {
        arguments.push_back("--peer");
        arguments.push_back(fo);
      }
    if (fetch && *fetch) arguments.push_back("--fetch");
    if (push && *push) arguments.push_back("--push");
    if (cache && *cache) arguments.push_back("--cache");
    if (async && *async) arguments.push_back("--async");
    if (readonly && *readonly) arguments.push_back("--readonly");
    if (cache_ram_size) {arguments.push_back("--cache-ram-size"); arguments.push_back(std::to_string(cache_ram_size.get()));}
    if (cache_ram_ttl) {arguments.push_back("--cache-ram-ttl"); arguments.push_back(std::to_string(cache_ram_ttl.get()));}
    if (cache_ram_invalidation) {arguments.push_back("--cache-ram-invalidation"); arguments.push_back(std::to_string(cache_ram_invalidation.get()));}
    if (cache_disk_size) {arguments.push_back("--cache-disk-size"); arguments.push_back(std::to_string(cache_disk_size.get()));}
    if (mountpoint)
    {
      arguments.push_back("--mountpoint");
      arguments.push_back(mountpoint.get());
    }
    if (as)
    {
      arguments.push_back("--as");
      arguments.push_back(as.get());
    }
  }

  struct Volume
    : public elle::Printable
  {
    Volume(QName name,
           std::string network_,
           MountOptions const& mount_options,
           boost::optional<std::string> default_permissions_)
      : name(std::move(name))
      , network(std::move(network_))
      , mount_options(mount_options)
      , default_permissions(std::move(default_permissions_))
    {
      check_name(this->name);
    }

    Volume(elle::serialization::SerializerIn& s)
    {
      this->serialize(s);
      check_name(this->name);
    }

    void
    serialize(elle::serialization::Serializer& s)
    {
      s.serialize("name", this->name);
      s.serialize("network", this->network);
      s.serialize("default_permissions", this->default_permissions);
      try
      {
        s.serialize("mount_options", this->mount_options);
      }
      catch (elle::Error const&e)
      {
        ELLE_TRACE("mount_options serialization error, assuming old version: %s", e);
      }
    }

    std::unique_ptr<reactor::filesystem::FileSystem>
    run(std::shared_ptr<model::doughnut::Doughnut> dht,
        boost::optional<std::string> mountpoint_ = {},
        boost::optional<bool> readonly = {},
        bool allow_root_creation = false
#if defined(INFINIT_MACOSX) || defined(INFINIT_WINDOWS)
        , boost::optional<std::string> volname_ = {}
#endif
#ifdef INFINIT_MACOSX
        , boost::optional<std::string> volicon_ = {}
#endif
    )
    {
#if defined(INFINIT_MACOSX) || defined(INFINIT_WINDOWS)
      if (!volname_)
        volname_ = this->name;
#endif
      {
        std::vector<std::string> opts;
        std::unordered_map<std::string, std::string> env;
        mount_options.to_commandline(opts, env);
        ELLE_TRACE("mount options: %s  environ %s", opts, env);
      }
      boost::optional<boost::filesystem::path> mountpoint;
      if (this->mount_options.mountpoint)
        mountpoint = boost::filesystem::path(this->mount_options.mountpoint.get());
      auto fs = elle::make_unique<filesystem::FileSystem>(
        infinit::filesystem::model = dht,
        infinit::filesystem::allow_root_creation = allow_root_creation,
        infinit::filesystem::volume_name = this->name,
        infinit::filesystem::root_block_cache_dir = this->root_block_cache_dir(),
        infinit::filesystem::mountpoint = mountpoint);
      auto driver =
        elle::make_unique<reactor::filesystem::FileSystem>(std::move(fs), true);
      if (mountpoint)
      {
        std::vector<std::string> fuse_options = {
          "infinit-volume",
          "-o", "noatime",
          "-o", "hard_remove",
        };
        if (mount_options.readonly && mount_options.readonly.get())
        {
          fuse_options.push_back("-o");
          fuse_options.push_back("ro");
        }
#ifndef INFINIT_WINDOWS
        if (mount_options.fuse_options)
        {
          for (auto const& opt: mount_options.fuse_options.get())
          {
            fuse_options.push_back("-o");
            fuse_options.push_back(opt);
          }
        }
#endif
#if defined(INFINIT_MACOSX) || defined(INFINIT_WINDOWS)
        auto add_option =
          [&fuse_options] (std::string const& opt_name,
                            std::string const& opt_val)
          {
            fuse_options.push_back("-o");
            fuse_options.push_back(elle::sprintf("%s=%s", opt_name, opt_val));
          };
        add_option("volname", volname_.get());
#endif
#ifdef INFINIT_MACOSX
        add_option("daemon_timeout", "600");
        if (volicon_)
          add_option("volicon", volicon_.get());
#endif
        driver->mount(mountpoint.get(), fuse_options);
      }
      return driver;
    }

    boost::filesystem::path
    root_block_cache_dir()
    {
      return xdg_state_home() / this->network / std::string(this->name);
    }

    void
    print(std::ostream& out) const override
    {
      out << "Volume(" << this->name << ")";
    }

    QName name;
    std::string network;
    MountOptions mount_options;
    boost::optional<std::string> default_permissions;
  };

  struct Drive
    : public elle::Printable
  {
    struct User
    {
      User() = default;

      User(std::string const& permissions,
           std::string const& status,
           bool create_home)
        : permissions(permissions)
        , status(status)
        , create_home(create_home)
      {}

      void
      serialize(elle::serialization::Serializer& s)
      {
        s.serialize("permissions", this->permissions);
        s.serialize("status", this->status);
        s.serialize("create_home", this->create_home);
      }

      bool
      operator==(User const& other)
      {
        return permissions == other.permissions
               && status == other.status
               && create_home == other.create_home;
      }

      std::string permissions = "rw";
      std::string status;
      bool create_home;
    };

    typedef std::unordered_map<std::string, User> Users;
  private:
    Drive(std::string const& name,
          std::string const& owner,
          std::string const& volume,
          std::string const& network,
          std::string const& description,
          Users const& users)
      : name(name)
      , owner(owner)
      , volume(volume)
      , network(network)
      , description(description)
      , users(users)
    {
      check_name(this->name);
    }

  public:
    Drive(std::string const& name,
          infinit::User const& owner,
          Volume const& volume,
          Network const& network,
          std::string const& description,
          Users const& users)
      : Drive(name, owner.name, volume.name, network.name, description, users)
    {
      if (this->users.find(owner.name) == this->users.end())
        this->users[owner.name] = User{"rw", "ok", false};
    }

    Drive(elle::serialization::SerializerIn& s)
      : Drive(s.deserialize<std::string>("name"),
              s.deserialize<std::string>("owner"),
              s.deserialize<std::string>("volume"),
              s.deserialize<std::string>("network"),
              s.deserialize<std::string>("description"),
              s.deserialize<Users>("users"))
    {}

    void
    serialize(elle::serialization::Serializer& s)
    {
      s.serialize("name", this->name);
      s.serialize("owner", this->owner);
      s.serialize("volume", this->volume);
      s.serialize("network", this->network);
      s.serialize("description", this->description);
      s.serialize("users", this->users);
      s.serialize("icon_path", this->icon_path);
    }

    void
    print(std::ostream& out) const override
    {
      out << "Drive(" << this->name << ")";
    }

    std::string name;
    std::string owner;
    std::string volume;
    std::string network;
    std::string description;
    Users users;
    boost::optional<std::string> icon_path;
  };

  template <typename T>
  T
  load(std::ifstream& input)
  {
    ELLE_ASSERT(input.is_open());
    return elle::serialization::json::deserialize<T>(
      input,
      false /* versioned */
    );
  }

  template <typename T>
  void
  save(std::ostream& output, T const& resource, bool pretty = true)
  {
    ELLE_ASSERT(output.good());
    elle::serialization::json::serialize(
      resource, output,
      false, /* versioned */
      pretty
    );
  }

  class Infinit
  {
  public:
    bool
    is_qualified_name(std::string const& object_name) const
    {
      return (object_name.find("/") != std::string::npos);
    }

    std::string
    qualified_name(std::string const& object_name, User const& owner) const
    {
      if (object_name.find("/") != std::string::npos)
        return object_name;
      else
        return elle::sprintf("%s/%s", owner.name, object_name);
    }

    Network
    network_get(std::string const& name_,
                User const& user,
                bool require_model = true)
    {
      auto name = qualified_name(name_, user);
      boost::filesystem::ifstream f;
      // Move linked networks found in the descriptor folder to the correct
      // place.
      bool move = false;
      try
      {
        this->_open_read(f, this->_network_path(name, user), name, "network");
      }
      catch (MissingLocalResource const&)
      {
        this->_open_read(
          f, this->_network_descriptor_path(name), name, "network");
        move = true;
      }
      auto res = elle::serialization::json::deserialize<Network>(f, false);
      std::string const not_linked_msg = elle::sprintf(
        "%s has not yet linked to the network \"%s\" on this device. "
        "Link using infinit-network --link", user.name, res.name);
      if (!res.model && require_model)
        elle::err(not_linked_msg);
      if (move && res.model)
      {
        // Ensure that passed user is same as that linked to network.
        if (!res.user_linked(user))
          elle::err(not_linked_msg);
        boost::filesystem::ifstream temp_f;
        this->_open_read(
          temp_f, this->_network_descriptor_path(name), name, "network");
        auto temp_net =
          elle::serialization::json::deserialize<Network>(temp_f, false);
        NetworkDescriptor desc(std::move(temp_net));
        auto old_path = this->_network_descriptor_path(res.name);
        auto path = this->_network_path(res.name, user);
        create_directories(path.parent_path());
        boost::filesystem::rename(old_path, path);
        this->network_save(desc);
      }
      return res;
    }

    std::vector<Network>
    networks_get(
      boost::optional<infinit::User> self, bool require_linked = false) const
    {
      namespace boost_fs = boost::filesystem;
      std::vector<Network> res;
      auto extract =
        [&] (boost::filesystem::path const& path, bool move) {
          for (boost_fs::recursive_directory_iterator it(path);
               it != boost_fs::recursive_directory_iterator();
               ++it)
          {
            if (!is_regular_file(it->status()) || is_hidden_file(it->path()))
              continue;
            boost_fs::ifstream f;
            this->_open_read(
              f, it->path(), "network", it->path().filename().string());
            auto network =
              elle::serialization::json::deserialize<Network>(f, false);
            if (require_linked && !network.model)
              continue;
            if (move && network.model && self && network.user_linked(*self))
            {
              boost::filesystem::ifstream temp_f;
              this->_open_read(
                temp_f, it->path(), "network", it->path().filename().string());
              auto temp_net =
                elle::serialization::json::deserialize<Network>(temp_f, false);
              NetworkDescriptor desc(std::move(temp_net));
              auto path = this->_network_path(network.name, *self);
              create_directories(path.parent_path());
              boost::filesystem::rename(it->path(), path);
              this->network_save(desc);
            }
            // Ignore duplicates.
            if (std::find_if(res.begin(), res.end(),
                  [&network] (Network const& n) {
                    return n.name == network.name;
                  }) == res.end())
            {
              res.push_back(std::move(network));
            }
          }
      };
      if (self)
      {
        // Start by linked networks first.
        extract(this->_network_path(*self), false);
      }
      // Then network descriptors and possibly old linked networks.
      extract(this->_network_descriptor_path(), true);
      return res;
    }

    std::vector<User>
    network_linked_users(std::string const& name_,
                         boost::optional<User> user = boost::none)
    {
      ELLE_ASSERT(is_qualified_name(name_) || user);
      auto name = name_;
      if (user)
        name = qualified_name(name_, *user);
      auto res = this->users_get();
      res.erase(
        std::remove_if(res.begin(), res.end(),
        [&] (infinit::User const& u)
        {
          return !boost::filesystem::exists(this->_network_path(name, u, false));
        }),
        res.end());
      return res;
    }

    void
    network_unlink(std::string const& name_, User const& user, bool report)
    {
      auto name = qualified_name(name_, user);
      auto network = this->network_get(name, user, true);
      auto path = this->_network_path(network.name, user);
      // XXX Should check async cache to make sure that it's empty.
      boost::filesystem::remove_all(network.cache_dir(user).parent_path());
      if (boost::filesystem::exists(path))
      {
        boost::system::error_code erc;
        boost::filesystem::remove(path, erc);
        if (!erc)
          report_action("Unlinked", "network", network.name);
        else
        {
          ELLE_WARN("Unable to unlink network \"%s\": %s",
                    network.name, erc.message());
        }
      }
    }

    void
    network_delete(
      std::string const& name_, User const& user, bool unlink, bool report)
    {
      // Ensure if unqualified name is passed, we qualify with passed user.
      auto name = qualified_name(name_, user);
      auto network = this->network_get(name, user, false);
      // Get a list of users who have linked the network.
      auto linked_users = this->network_linked_users(name);
      if (linked_users.size() && !unlink)
      {
        std::vector<std::string> user_names;
        for (auto const& u: linked_users)
          user_names.emplace_back(u.name);
        throw elle::Error(elle::sprintf(
          "Network is still linked with this device by %s.", user_names));
      }
      boost::system::error_code erc;
      for (auto const& u: linked_users)
      {
        auto linked_path = this->_network_path(name, u);
        boost::filesystem::remove(linked_path, erc);
        boost::filesystem::remove_all(network.cache_dir(u).parent_path());
        if (erc)
        {
          ELLE_WARN("Unable to unlink network \"%s\" for \"%s\": %s",
                    name, u.name, erc.message());
        }
        else if (report)
          report_action("unlinked", "network", name);
      }
      auto desc_path = this->_network_descriptor_path(name);
      boost::filesystem::remove(desc_path, erc);
      if (erc)
      {
        ELLE_WARN("Unable to remove network descriptor \"%s\": %s",
                  name, erc.message());
      }
      else if (report)
        report_action("deleted", "network", name);
    }

    std::vector<Drive>
    drives_get() const
    {
      namespace boost_fs = boost::filesystem;
      std::vector<Drive> res;
      for (boost_fs::recursive_directory_iterator it(this->_drive_path());
           it != boost_fs::recursive_directory_iterator();
           ++it)
      {
        if (is_regular_file(it->status()) && !is_hidden_file(it->path()))
        {
          boost_fs::ifstream f;
          this->_open_read(
            f, it->path(), it->path().filename().string(), "drive");
          res.push_back(load<Drive>(f));
        }
      }
      return res;
    }

    NetworkDescriptor
    network_descriptor_get(std::string const& name_,
                           User const& owner,
                           bool or_network = true)
    {
      auto name = qualified_name(name_, owner);
      try
      {
        boost::filesystem::ifstream f;
        try
        {
          this->_open_read(f, this->_network_path(name, owner), name, "network");
        }
        catch (MissingLocalResource const&)
        {
          this->_open_read(f, this->_network_descriptor_path(name), name, "network");
        }
        elle::serialization::json::SerializerIn s(f, false);
        return s.deserialize<NetworkDescriptor>();
      }
      catch (elle::serialization::Error const&)
      {
        if (or_network)
        {
          try
          {
            return NetworkDescriptor(this->network_get(name_, owner));
          }
          catch (elle::Error const&)
          {}
        }
        throw;
      }
    }

    void
    network_save(NetworkDescriptor const& network, bool overwrite = false) const
    {
      boost::filesystem::ofstream f;
      this->_open_write(f, this->_network_descriptor_path(network.name),
                        network.name, "network", overwrite);
      save(f, network);
    }

    void
    network_save(infinit::User const& self,
                 Network const& network, bool overwrite = false) const
    {
      boost::filesystem::ofstream f;
      this->_open_write(f, this->_network_path(network.name, self),
                        network.name, "network", overwrite);
      save(f, network);
    }

    Passport
    passport_get(std::string const& network, std::string const& user)
    {
      boost::filesystem::ifstream f;
      this->_open_read(f, this->_passport_path(network, user),
                       elle::sprintf("%s: %s", network, user), "passport");
      return load<Passport>(f);
    }

    std::vector<std::pair<Passport, std::string>>
    passports_get(boost::optional<std::string> network = boost::none)
    {
      namespace boost_fs = boost::filesystem;
      std::vector<std::pair<Passport, std::string>> res;
      boost_fs::path path;
      if (network)
        path = this->_passport_path() / network.get();
      else
        path = this->_passport_path();
      if (!boost::filesystem::exists(path))
        return res;
      for (boost_fs::recursive_directory_iterator it(path);
           it != boost_fs::recursive_directory_iterator();
           ++it)
      {
        if (is_regular_file(it->status()) && !is_hidden_file(it->path()))
        {
          auto user_name = it->path().filename().string();
          boost_fs::ifstream f;
          this->_open_read(f, it->path(), user_name, "passport");
          auto passport =
            elle::serialization::json::deserialize<infinit::Passport>(f, false);
          res.push_back(std::pair<Passport, std::string>(passport, user_name));
        }
      }
      return res;
    }

    void
    passport_save(Passport const& passport, bool overwrite = false)
    {
      boost::filesystem::ofstream f;
      auto users = this->users_get();
      for (auto const& user: users)
      {
        if (user.public_key == passport.user())
        {
          this->_open_write(f,
                            this->_passport_path(passport.network(), user.name),
                            elle::sprintf("%s: %s", passport.network(),
                                          user.name),
                            "passport", overwrite);
          elle::serialization::json::SerializerOut s(f, false, true);
          s.serialize_forward(passport);
          return;
        }
      }
      throw elle::Error(elle::sprintf(
        "unable to save passport, user not found locally: %s",
        passport.user()));
    }

    void
    user_save(User const& user,
              bool overwrite = false)
    {
      auto path = this->_user_path(user.name);
      boost::filesystem::ofstream f;
      this->_open_write(f, path, user.name, "user", overwrite);
      save(f, user);
#ifndef INFINIT_WINDOWS
      boost::filesystem::permissions(path,
        boost::filesystem::remove_perms
        | boost::filesystem::others_all | boost::filesystem::group_all);
#endif
    }

    User
    user_get(std::string const& user, bool beyond_fallback = false) const
    {
      try
      {
        boost::filesystem::ifstream f;
        this->_open_read(f, this->_user_path(user), user, "user");
        return load<User>(f);
      }
      catch (MissingLocalResource const& e)
      {
        if (!beyond_fallback)
          throw;
        ELLE_LOG("User %s not found locally, trying on %s", user, beyond(true));
        auto u = beyond_fetch<User>("user", user);
        return u;
      }
    }

    std::vector<User>
    users_get() const
    {
      namespace boost_fs = boost::filesystem;
      std::vector<User> res;
      for (boost_fs::recursive_directory_iterator it(this->_user_path());
           it != boost_fs::recursive_directory_iterator();
           ++it)
      {
        if (is_regular_file(it->status()) && !is_hidden_file(it->path()))
        {
          boost_fs::ifstream f;
          this->_open_read(
            f, it->path(), it->path().filename().string(), "user");
          res.push_back(load<User>(f));
        }
      }
      return res;
    }

    boost::filesystem::path
    _user_avatar_path() const
    {
      auto root = xdg_cache_home() / "avatars";
      create_directories(root);
      return root;
    }

    boost::filesystem::path
    _user_avatar_path(std::string const& name) const
    {
      return this->_user_avatar_path() / name;
    }

    std::unique_ptr<storage::StorageConfig>
    storage_get(std::string const& name)
    {
      boost::filesystem::ifstream f;
      this->_open_read(f, this->_storage_path(name), name, "storage");
      return load<std::unique_ptr<storage::StorageConfig>>(f);
    }

    std::vector<std::unique_ptr<storage::StorageConfig>>
    storages_get()
    {
      namespace boost_fs = boost::filesystem;
      std::vector<std::unique_ptr<storage::StorageConfig>> res;
      for (boost_fs::recursive_directory_iterator it(this->_storage_path());
           it != boost_fs::recursive_directory_iterator();
           ++it)
      {
        if (is_regular_file(it->status()) && !is_hidden_file(it->path()))
        {
          res.emplace_back(storage_get(it->path().filename().string()));
        }
      }
      return res;
    }

    void
    storage_save(std::string const& name,
                 std::unique_ptr<storage::StorageConfig> const& storage)
    {
      boost::filesystem::ofstream f;
      this->_open_write(f, this->_storage_path(name), name, "storage", false);
      elle::serialization::json::SerializerOut s(f, false, true);
      s.serialize_forward(storage);
    }

    void
    storage_remove(std::string const& name)
    {
      auto path = this->_storage_path(name);
      if (!remove(path))
      {
        throw elle::Error(
          elle::sprintf("storage \"%s\" does not exist", name));
      }
    }

    Volume
    volume_get(std::string const& name)
    {
      boost::filesystem::ifstream f;
      this->_open_read(f, this->_volume_path(name), name, "volume");
      return load<Volume>(f);
    }

    void
    volume_save(Volume const& volume, bool overwrite = false)
    {
      boost::filesystem::ofstream f;
      this->_open_write(
        f, this->_volume_path(volume.name), volume.name, "volume", overwrite);
      save(f, volume);
    }

    std::vector<Volume>
    volumes_get() const
    {
      namespace boost_fs = boost::filesystem;
      std::vector<Volume> res;
      for (boost_fs::recursive_directory_iterator it(this->_volume_path());
           it != boost_fs::recursive_directory_iterator();
           ++it)
      {
        if (is_regular_file(it->status()) && !is_hidden_file(it->path()))
        {
          boost_fs::ifstream f;
          this->_open_read(
            f, it->path(), it->path().filename().string(), "volume");
          res.push_back(load<Volume>(f));
        }
      }
      return res;
    }

    void
    credentials_add(std::string const& name, std::unique_ptr<Credentials> a)
    {
      auto path = this->_credentials_path(name, elle::sprintf("%s", a->uid()));
      boost::filesystem::ofstream f;
      this->_open_write(f, path, name, "credential");
      save(f, a);
    }

    template <typename T = infinit::Credentials>
    std::vector<
      std::unique_ptr<
        T,
        std::default_delete<infinit::Credentials>
        >
      >
    credentials(std::string const& name) const
    {
      std::vector<
        std::unique_ptr<
          T,
          std::default_delete<infinit::Credentials>
          >
        > res;
      auto const path = this->_credentials_path(name);
      boost::filesystem::directory_iterator const end;
      for (boost::filesystem::directory_iterator it(path);
           it != end;
           ++it)
      {
        if (is_regular_file(it->status()))
        {
          boost::filesystem::ifstream f;
          this->_open_read(f, it->path(), name, "credential");
          res.push_back(std::dynamic_pointer_cast<T>(load<std::unique_ptr<Credentials>>(f)));
        }
      }
      return res;
    }

    std::unique_ptr<Credentials>
    credentials(std::string const& name, std::string const& identifier) const
    {
      for (auto& account: this->credentials(name))
      {
        if (account->display_name() == identifier ||
            account->uid() == identifier)
        {
          return std::move(account);
        }
      }
      throw elle::Error(
        elle::sprintf("no such %s account: %s", name, identifier));
    }

    void
    credentials_aws_add(std::unique_ptr<Credentials> a)
    {
      this->credentials_add("aws", std::move(a));
    }

    std::vector<
      std::unique_ptr<
        AWSCredentials,
        std::default_delete<infinit::Credentials>
        >
      >
    credentials_aws() const
    {
      return this->credentials<AWSCredentials>("aws");
    }

    std::unique_ptr<AWSCredentials, std::default_delete<infinit::Credentials>>
    credentials_aws(std::string const& uid) const
    {
      auto res = this->credentials("aws", uid);
      return std::dynamic_pointer_cast<AWSCredentials>(res);
    }

    void
    credentials_dropbox_add(std::unique_ptr<Credentials> a)
    {
      this->credentials_add("dropbox", std::move(a));
    }

    std::vector<
      std::unique_ptr<
      OAuthCredentials,
        std::default_delete<infinit::Credentials>
        >
      >
    credentials_dropbox() const
    {
      return this->credentials<OAuthCredentials>("dropbox");
    }

    std::unique_ptr<OAuthCredentials, std::default_delete<infinit::Credentials>>
    credentials_dropbox(std::string const& uid) const
    {
      auto res = this->credentials("dropbox", uid);
      return std::dynamic_pointer_cast<OAuthCredentials>(res);
    }

    void
    credentials_google_add(std::unique_ptr<Credentials> a)
    {
      this->credentials_add("google", std::move(a));
    }

    std::vector<
      std::unique_ptr<
        OAuthCredentials,
        std::default_delete<infinit::Credentials>
        >
      >
    credentials_google() const
    {
      return this->credentials<OAuthCredentials>("google");
    }

    std::unique_ptr<OAuthCredentials, std::default_delete<infinit::Credentials>>
    credentials_google(std::string const& uid) const
    {
      auto res = this->credentials("google", uid);
      return std::dynamic_pointer_cast<OAuthCredentials>(res);
    }

    void
    credentials_gcs_add(std::unique_ptr<Credentials> a)
    {
      this->credentials_add("gcs", std::move(a));
    }

    std::vector<
      std::unique_ptr<
        OAuthCredentials,
        std::default_delete<infinit::Credentials>
        >
      >
    credentials_gcs() const
    {
      return this->credentials<OAuthCredentials>("gcs");
    }

    std::unique_ptr<OAuthCredentials, std::default_delete<infinit::Credentials>>
    credentials_gcs(std::string const& uid) const
    {
      auto res = this->credentials("gcs", uid);
      return std::dynamic_pointer_cast<OAuthCredentials>(res);
    }

    boost::filesystem::path
    _credentials_path(std::string const& service) const
    {
      auto root = xdg_data_home() / "credentials" / service;
      create_directories(root);
      return root;
    }

    boost::filesystem::path
    _credentials_path(std::string const& service, std::string const& name) const
    {
      return this->_credentials_path(service) / name;
    }

    boost::filesystem::path
    _network_descriptor_path() const
    {
      auto root = xdg_data_home() / "networks";
      create_directories(root);
      return root;
    }

    boost::filesystem::path
    _network_descriptor_path(std::string const& name) const
    {
      return this->_network_descriptor_path() / name;
    }

    boost::filesystem::path
    _network_path(User const& user, bool create_dir = true) const
    {
      auto root = xdg_data_home() / "linked_networks" / user.name;
      if (create_dir)
        create_directories(root);
      return root;
    }

    boost::filesystem::path
    _network_path(std::string const& name,
                  User const& user,
                  bool create_dir = true) const
    {
      auto network_name = this->qualified_name(name, user);
      return this->_network_path(user, create_dir) / network_name;
    }

    boost::filesystem::path
    _passport_path() const
    {
      auto root = xdg_data_home() / "passports";
      create_directories(root);
      return root;
    }

    boost::filesystem::path
    _passport_path(std::string const& network, std::string const& user) const
    {
      return this->_passport_path() / network / user;
    }

    boost::filesystem::path
    _storage_path() const
    {
      auto root = xdg_data_home() / "storages";
      create_directories(root);
      return root;
    }

    boost::filesystem::path
    _storage_path(std::string const& name) const
    {
      return _storage_path() / name;
    }

    boost::filesystem::path
    _user_path() const
    {
      auto root = xdg_data_home() / "users";
      create_directories(root);
      return root;
    }

    boost::filesystem::path
    _user_path(std::string const& name) const
    {
      return this->_user_path() / name;
    }

    boost::filesystem::path
    _volume_path() const
    {
      auto root = xdg_data_home() / "volumes";
      create_directories(root);
      return root;
    }

    boost::filesystem::path
    _volume_path(std::string const& name) const
    {
      return this->_volume_path() / name;
    }

    void
    _open_read(boost::filesystem::ifstream& f,
               boost::filesystem::path const& path,
               std::string const& name,
               std::string const& type) const
    {
      ELLE_DEBUG("open %s \"%s\" (%s) for reading", type, name, path);
      f.open(path);
      if (!f.good())
      {
        throw MissingLocalResource(
          elle::sprintf("%s \"%s\" does not exist", type, name));
      }
    }

    void
    _open_write(boost::filesystem::ofstream& f,
                boost::filesystem::path const& path,
                std::string const& name,
                std::string const& type,
                bool overwrite = false,
                std::ios_base::openmode mode = std::ios_base::out) const
    {
      ELLE_DEBUG("open %s \"%s\" (%s) for writing", type, name, path);
      create_directories(path.parent_path());
      if (!overwrite && exists(path))
      {
        throw ResourceAlreadyFetched(
          elle::sprintf("%s \"%s\" already exists", type, name));
      }
      f.open(path, mode);
      if (!f.good())
      {
        throw elle::Error(
          elle::sprintf("unable to open \"%s\" for writing", path));
      }
    }

    boost::filesystem::path
    _drive_path() const
    {
      auto root = xdg_data_home() / "drives";
      create_directories(root);
      return root;
    }

    boost::filesystem::path
    _drive_path(std::string const& name) const
    {
      return this->_drive_path() / name;
    }

    void
    drive_save(Drive const& drive,
               bool overwrite = true)
    {
      boost::filesystem::ofstream f;
      this->_open_write(f, this->_drive_path(drive.name), drive.name, "drive",
                        overwrite);
      save(f, drive);
    }

    Drive
    drive_get(std::string const& name)
    {
      boost::filesystem::ifstream f;
      this->_open_read(f, this->_drive_path(name), name, "drive");
      return load<Drive>(f);
    }

    bool
    drive_delete(std::string const& name)
    {
      boost::filesystem::path drive_path = this->_drive_path(name);
      if (boost::filesystem::exists(drive_path))
        return boost::filesystem::remove(drive_path);
      return false;
    }

    boost::filesystem::path
    _drive_icon_path() const
    {
      auto root = xdg_cache_home() / "icons";
      create_directories(root);
      return root;
    }

    boost::filesystem::path
    _drive_icon_path(std::string const& name) const
    {
      return this->_drive_icon_path() / name;
    }

    Drive
    drive_fetch(std::string const& name);

    std::vector<std::string>
    user_passports_for_network(std::string const& network_name)
    {
      std::vector<std::string> res;
      for (auto const& pair: this->passports_get(network_name))
        res.push_back(pair.second);
      return res;
    }

    std::vector<std::string>
    volumes_for_network(std::string const& network_name)
    {
      std::vector<std::string> res;
      for (auto const& volume: this->volumes_get())
      {
        if (volume.network == network_name)
          res.push_back(volume.name);
      }
      return res;
    }

    std::vector<std::string>
    drives_for_volume(std::string const& volume_name)
    {
      std::vector<std::string> res;
      for (auto const& drive: this->drives_get())
      {
        if (drive.volume == volume_name)
          res.push_back(drive.name);
      }
      return res;
    }
  };
#ifndef INFINIT_WINDOWS
  typedef int DaemonHandle;
  DaemonHandle daemon_hold(int nochdir, int noclose);
  void daemon_release(DaemonHandle handle);
#endif
}

inline
boost::filesystem::path
daemon_sock_path()
{
  return infinit::xdg_runtime_dir() / "daemon.sock";
}

inline
bool
_one(bool seen)
{
  return seen;
}

template <typename First, typename ... Args>
bool
_one(bool seen, First&& first, Args&& ... args)
{
  auto b = bool(first);
  if (seen && b)
    return false;
  return _one(seen || b, std::forward<Args>(args)...);
}

template <typename ... Args>
bool
one(Args&& ... args)
{
  return _one(false, std::forward<Args>(args)...);
}

template <typename ... Args>
bool
none(Args&& ... args)
{
  return true;
}

template <typename First, typename ... Args>
bool
none(First&& first, Args&& ... args)
{
  return first ? false : none(std::forward<Args>(args)...);
}

template <typename First, typename ... Args>
bool
all(First&& first, Args&& ... args)
{
  return !first ? false : none(std::forward<Args>(args)...);
}

template <typename ... Args>
bool
all(Args&& ... args)
{
  return true;
}

inline
Mode::OptionDescription
option_output(std::string const& item)
{
  return Mode::OptionDescription(
    "output,o", boost::program_options::value<std::string>(),
    elle::sprintf("file to write the %s to\n(default: stdout)", item).c_str());
}

inline
std::unique_ptr<std::ostream, std::function<void (std::ostream*)>>
get_output(boost::program_options::variables_map const& args)
{
  if (args.count("output"))
  {
    auto dest = args["output"].as<std::string>();
    if (dest != "-")
    {
      std::unique_ptr<std::ostream, std::function<void (std::ostream*)>> file
        (new std::ofstream(dest), [] (std::ostream* p) { delete p; });
      if (!file->good())
      {
        throw elle::Error(
          elle::sprintf("unable to open \"%s\" for writing", dest));
      }
      return file;
    }
  }
  return std::unique_ptr<std::ostream, std::function<void (std::ostream*)>>
    (&std::cout, [] (std::ostream*) {});
}

inline
Mode::OptionDescription
option_input(std::string const& item)
{
  return Mode::OptionDescription(
    "input,i", boost::program_options::value<std::string>(),
    elle::sprintf("file to read the %s from (default: stdin)", item).c_str());
}

inline
std::unique_ptr<std::istream, std::function<void (std::istream*)>>
get_input(boost::program_options::variables_map const& args)
{
  if (args.count("input"))
  {
    auto dest = args["input"].as<std::string>();
    if (dest != "-")
    {
      std::unique_ptr<std::istream, std::function<void (std::istream*)>> file
        (new std::ifstream(dest), [] (std::istream* p) { delete p; });
      if (!file->good())
      {
        throw elle::Error(
          elle::sprintf("unable to open \"%s\" for reading", dest));
      }
      return file;
    }
  }
  return std::unique_ptr<std::istream, std::function<void (std::istream*)>>
    (&std::cin, [] (std::istream*) {});
}

inline
std::string
get_username(boost::program_options::variables_map const& args,
             std::string const& name)
{
  auto opt = optional(args, name);
  if (name == "as")
  {
    if (_as_user)
      return _as_user.get();
  }
  else if (name == "name")
  {
    if (opt)
      return opt.get();
    else if (_as_user)
      return _as_user.get();
  }
  else if (opt)
    return opt.get();
  std::string env = elle::os::getenv("INFINIT_USER", "");
  return env.empty() ? elle::system::username() : env;
}

DAS_MODEL_FIELDS(
  infinit::User,
  (name, email, fullname, avatar_path, public_key, private_key, password_hash, ldap_dn));

DAS_MODEL(
  infinit::MountOptions,
  (hub_url
  ,rdv
  ,fuse_options
  ,fetch
  ,push
  ,cache
  ,async
  ,readonly
  ,cache_ram_size
  ,cache_ram_ttl
  ,cache_ram_invalidation
  ,cache_disk_size
  ,mountpoint
  ,as
  ,peers), DasMountOptions);
DAS_MODEL_DEFAULT(infinit::MountOptions, DasMountOptions);
DAS_MODEL_SERIALIZE(infinit::MountOptions);

namespace infinit
{
  DAS_MODEL_DEFINE(User, (name, fullname, avatar_path,  public_key, ldap_dn), DasPublicUser);
  DAS_MODEL_DEFINE(User, (name, email, avatar_path, fullname, public_key, ldap_dn, private_key),
                   DasUser);
  // Publication to the hub.
  DAS_MODEL_DEFINE(User, (name, email, fullname, public_key, ldap_dn),
                   DasPublicUserPublish);
  DAS_MODEL_DEFINE(
    User, (name, email, fullname, public_key, private_key, ldap_dn, password_hash),
    DasPrivateUserPublish);
}

typedef std::unordered_map<std::string, std::string> Headers;

struct FakeRedirect
{
  boost::optional<std::string> url;
};

DAS_MODEL(FakeRedirect, (url), DasFakeRedirect);
DAS_MODEL_DEFAULT(FakeRedirect, DasFakeRedirect);
DAS_MODEL_SERIALIZE(FakeRedirect);

static
Headers
signature_headers(
  reactor::http::Method method,
  std::string const& where,
  infinit::User const& self,
  boost::optional<elle::ConstWeakBuffer> payload = {})
{
  if (!self.private_key)
    elle::err("no private key for %s, unable to sign request", self.name);
  using namespace infinit::cryptography;
  auto semi_colon_append = [](elle::Buffer& buffer, std::string const& str)
    {
      std::string res = elle::sprintf("%s;", str);
      return buffer.append(res.data(), res.size());
    };
  elle::Buffer string_to_sign = elle::Buffer();
  semi_colon_append(string_to_sign, elle::sprintf("%s", method));
  semi_colon_append(string_to_sign, where);
  elle::Buffer payload_hash;
  if (payload)
    payload_hash = hash(payload.get(), Oneway::sha256);
  else
    payload_hash = hash(elle::ConstWeakBuffer(), Oneway::sha256);
  auto encoded_hash = elle::format::base64::encode(payload_hash);
  semi_colon_append(string_to_sign, encoded_hash.string());
  auto now = std::to_string(time(0));
  string_to_sign.append(now.data(), now.size());
  auto signature = self.private_key->sign(
    string_to_sign,
    infinit::cryptography::rsa::Padding::pkcs1,
    infinit::cryptography::Oneway::sha256);
  auto encoded_signature = elle::format::base64::encode(signature);
  std::unordered_map<std::string, std::string> res = {
    { "infinit-signature", encoded_signature.string() },
    { "infinit-time", now },
    { "infinit-user", self.name },
  };
  return res;
}

namespace detail
{
  template <typename Exception>
  void
  _read_error(elle::json::Object& request)
  {
    auto error = boost::any_cast<std::string>(request["error"]);
    throw Exception(error);
  }

  template <>
  inline
  void
  _read_error<BeyondError>(elle::json::Object& request)
  {
    auto error = boost::any_cast<std::string>(request["error"]);
    auto reason = boost::any_cast<std::string>(request["reason"]);
    boost::optional<std::string> name = boost::none;
    if (request.find("name") != request.end())
      name = boost::any_cast<std::string>(request["name"]);
    throw BeyondError(error, reason, name);
  }
}

template <typename Exception>
void
read_error(reactor::http::Request& r,
           std::string const& type,
           std::string const& name)
{
  ELLE_DEBUG("read_error");
  elle::json::Object json;
  try
  {
    json = boost::any_cast<elle::json::Object>(elle::json::read(r));
  }
  catch (boost::bad_any_cast const& e)
  {
    ELLE_DEBUG("Not json. html ?");
    throw elle::Error(e.what());
  }
  catch (elle::json::ParseError const& e)
  {
    ELLE_DEBUG("ParseError: %s", e.what());
    throw elle::Error(
      elle::sprintf("unexpected HTTP error %s while performing %s for %s %s",
                    r.status(), r.method(), type, name));
  }
  detail::_read_error<Exception>(json);
}

inline
void
_beyond_push(reactor::http::Request& r,
             std::string const& type,
             std::string const& name,
             bool report = false,
             bool beyond_error = false,
             bool update = false)
{
  r.finalize();
  reactor::wait(r);
  if (r.status() == reactor::http::StatusCode::Created)
  {
    if (report)
      report_action("saved", type, name, std::string("remotely"));
  }
  else if (r.status() == reactor::http::StatusCode::OK)
  {
    if (report && update)
      report_action("updated", type, name, std::string("remotely"));
    else
      report_action("already pushed", type, name);
  }
  else if (r.status() == reactor::http::StatusCode::Conflict)
  {
    throw elle::Error(
      elle::sprintf(
        "%s \"%s\" already exists with a different key", type, name));
  }
  else if (r.status() == reactor::http::StatusCode::Payment_Required)
  {
    throw elle::Error(
      elle::sprintf(
        "Pushing %s failed (limit reached): Please contact sales@infinit.sh.",
        type));
  }
  else if (r.status() == reactor::http::StatusCode::Not_Found)
  {
    if (beyond_error)
      read_error<BeyondError>(r, type, name);
    else
      read_error<MissingResource>(r, type, name);
  }
  else if (r.status() == reactor::http::StatusCode::See_Other ||
           r.status() == reactor::http::StatusCode::Temporary_Redirect)
  {
    throw Redirected(r.url());
  }
  else if (r.status() == reactor::http::StatusCode::Gone)
  {
    read_error<ResourceGone>(r, type, name);
  }
  else if (r.status() == reactor::http::StatusCode::Unauthorized)
  {
    throw elle::Error(
      elle::sprintf("Unauthorized pushing %s \"%s\", check the system clock",
                    type, name));
  }
  else if (r.status() == reactor::http::StatusCode::Forbidden)
  {
    throw elle::Error(
      elle::sprintf("Forbidden pushing %s \"%s\", "
                    "ensure the user has been set using --as or INFINIT_USER",
                    type, name));
  }
  else
  {
    auto error = [&] {
      try
      {
        auto s = elle::serialization::json::SerializerIn{r, false};
        return s.deserialize<BeyondError>();
      }
      catch (elle::serialization::Error const&)
      {}
      return BeyondError("unknown", "Unknown error");
    }();
    if (error.error() == std::string("user/missing_field/email"))
      throw elle::Error("email unspecified (use --email)");
    if (error.error() == std::string("user/invalid_format/email"))
      throw elle::Error("email address is invalid");
    throw elle::Error(
      elle::sprintf("unexpected HTTP error %s pushing %s:\n%s",
                    r.status(), type, error));
  }
}

inline
void
beyond_push_data(std::string const& where,
                 std::string const& type,
                 std::string const& name,
                 elle::ConstWeakBuffer const& object,
                 std::string const& content_type,
                 infinit::User const& self,
                 bool report = true,
                 bool beyond_error = false,
                 bool update = false)
{
  reactor::http::Request::Configuration c;
  c.header_add("Content-Type", content_type);
  auto headers = signature_headers(
    reactor::http::Method::PUT, where, self, object);
  for (auto const& header: headers)
    c.header_add(header.first, header.second);
  reactor::http::Request r(
    elle::sprintf("%s/%s", beyond(), where),
    reactor::http::Method::PUT, std::move(c));
  r << object.string();
  _beyond_push(r, type, name, report, beyond_error, update);
}

template <typename T>
void
beyond_push(std::string const& where,
            std::string const& type,
            std::string const& name,
            T const& o,
            infinit::User const& self,
            bool report,
            bool beyond_error,
            bool update)
{
  std::stringstream stream;
  elle::serialization::json::serialize(o, stream, false);
  auto payload_ = stream.str();
  ELLE_TRACE("pushing %s/%s with payload %s", type, name, payload_);
  elle::ConstWeakBuffer payload{payload_.data(), payload_.size()};
  beyond_push_data(
    where, type, name, payload, "application/json", self, report, beyond_error,
    update);
}

template <typename T>
void
beyond_push(std::string const& type,
            std::string const& name,
            T const& o,
            infinit::User const& self,
            bool report = true,
            bool beyond_error = false,
            bool update = false)
{
  beyond_push(elle::sprintf("%ss/%s", type, name), type, name, o, self, report,
      beyond_error, update);
}

static
std::unique_ptr<reactor::http::Request>
fetch_data(std::string const& url,
           std::string const& type,
           std::string const& name,
           Headers const& extra_headers = Headers{},
           bool output_report_action = true)
{
  Headers headers;
  for (auto const& header: extra_headers)
    headers[header.first] = header.second;
  reactor::http::Request::Configuration c;
  for (auto const& header: headers)
    c.header_add(header.first, header.second);
  auto r = elle::make_unique<reactor::http::Request>(
    url, reactor::http::Method::GET, std::move(c));
  reactor::wait(*r);
  if (r->status() == reactor::http::StatusCode::OK)
  {
    if (output_report_action)
      report_action("fetched", type, name);
  }
  else if (r->status() == reactor::http::StatusCode::Not_Found)
  {
    read_error<MissingResource>(*r, type, name);
  }
  else if (r->status() == reactor::http::StatusCode::Gone)
  {
    read_error<ResourceGone>(*r, type, name);
  }
  else if (r->status() == reactor::http::StatusCode::Forbidden)
  {
    read_error<ResourceProtected>(*r, type, name);
  }
  else if (r->status() == reactor::http::StatusCode::See_Other ||
           r->status() == reactor::http::StatusCode::Temporary_Redirect)
  {
    auto redirection = r->headers().find("Location");
    if (redirection != r->headers().end())
    {
      auto new_url = redirection->second;
      if (!new_url.empty() && new_url != url)
      {
        return fetch_data(new_url, type, name);
      }
    }
  }
  else if (r->status() == reactor::http::StatusCode::Unauthorized)
  {
    throw elle::Error(
      elle::sprintf("Unauthorized fetching %s \"%s\", check the system clock",
                    type, name));
  }
  else
  {
    throw elle::Error(
      elle::sprintf("unexpected HTTP error %s fetching %s",
                    r->status(), type));
  }
  return r;
}

static
std::unique_ptr<reactor::http::Request>
beyond_fetch_data(std::string const& where,
                  std::string const& type,
                  std::string const& name,
                  boost::optional<infinit::User const&> self = boost::none,
                  Headers const& extra_headers = Headers{},
                  bool output_report_action = true)
{
  Headers headers;
  if (self)
  {
    headers = signature_headers(reactor::http::Method::GET, where, self.get());
  }
  for (auto const& header: extra_headers)
    headers[header.first] = header.second;
  return fetch_data(elle::sprintf("%s/%s", beyond(), where),
                    type,
                    name,
                    headers,
                    output_report_action);
}

inline
elle::json::Json
beyond_fetch_json(std::string const& where,
                  std::string const& type,
                  std::string const& name,
                  boost::optional<infinit::User const&> self = boost::none,
                  Headers const& extra_headers = Headers{},
                  bool output_report_action = true)
{
  auto r = beyond_fetch_data(
    where, type, name, self, extra_headers, output_report_action);
  return elle::json::read(*r);
}

template <typename T>
T
beyond_fetch(std::string const& where,
             std::string const& type,
             std::string const& name,
             boost::optional<infinit::User const&> self = boost::none,
             Headers const& extra_headers = Headers{},
             bool output_report_action = true)
{
  auto json = beyond_fetch_json(
    where, type, name, self, extra_headers, output_report_action);
  elle::serialization::json::SerializerIn input(json, false);
  return input.deserialize<T>();
}

template <typename T>
T
beyond_fetch(std::string const& type,
             std::string const& name)
{
  return beyond_fetch<T>(elle::sprintf("%ss/%s", type, name), type, name);
}

inline
void
beyond_delete(std::string const& where,
              std::string const& type,
              std::string const& name,
              infinit::User const& self,
              bool ignore_missing = false,
              bool purge = false)
{
  reactor::http::Request::Configuration c;
  auto headers = signature_headers(reactor::http::Method::DELETE,
                                   where,
                                   self);
  for (auto const& header: headers)
    c.header_add(header.first, header.second);
  auto url = elle::sprintf("%s/%s", beyond(), where);
  reactor::http::Request::QueryDict query;
  if (purge)
    query["purge"] = "true";
  reactor::http::Request r(url, reactor::http::Method::DELETE, std::move(c));
  r.query_string(query);
  r.finalize();
  reactor::wait(r);
  if (r.status() == reactor::http::StatusCode::OK)
  {
    report_action(elle::sprintf("deleted%s", purge ? " and purged" : ""),
                  type, name, std::string("remotely"));
  }
  else if (r.status() == reactor::http::StatusCode::Not_Found)
  {
    if (!ignore_missing)
      read_error<MissingResource>(r, type, name);
  }
  else if (r.status() == reactor::http::StatusCode::See_Other ||
           r.status() == reactor::http::StatusCode::Temporary_Redirect)
  {
    throw Redirected(url);
  }
  else if (r.status() == reactor::http::StatusCode::Unauthorized)
  {
    throw elle::Error(
      elle::sprintf("Unauthorized deleting %s \"%s\", check the system clock",
                    type, name));
  }
  else if (r.status() == reactor::http::StatusCode::Forbidden)
  {
    throw elle::Error(
      elle::sprintf("Forbidden deleting %s \"%s\", "
                    "ensure the user has been set using --as or INFINIT_USER",
                    type, name));
  }
  else
  {
    ELLE_LOG("HTTP response: %s", r.response());
    throw elle::Error(
      elle::sprintf("unexpected HTTP error %s deleting %s \"%s\"",
                    r.status(), type, name));
  }
}

inline
void
beyond_delete(std::string const& type,
              std::string const& name,
              infinit::User const& self,
              bool ignore_missing = false,
              bool purge = false)
{
  beyond_delete(elle::sprintf("%ss/%s", type, name), type, name, self,
                ignore_missing, purge);
}

inline
static
std::string
self_user_name(boost::program_options::variables_map const& args)
{
  return get_username(args, "as");
}

inline
static
infinit::User
self_user(infinit::Infinit const& ifnt,
          boost::program_options::variables_map const& args,
          bool private_mandatory = true)
{
  auto res = ifnt.user_get(self_user_name(args));
  if (private_mandatory && !res.private_key)
  {
    throw elle::Error(
      elle::sprintf("user \"%s\" has no private key", res.name));
  }
  return res;
}

struct Endpoints
{
  std::vector<std::string> addresses;
  int port;
};

DAS_MODEL(Endpoints, (addresses, port), DasEndpoints);
DAS_MODEL_DEFAULT(Endpoints, DasEndpoints);
DAS_MODEL_SERIALIZE(Endpoints);

class InterfacePublisher
{
public:
  friend class elle::With<InterfacePublisher>;
private:
  InterfacePublisher(infinit::Network const& network,
                     infinit::User const& self,
                     infinit::model::Address const& node_id,
                     int port,
                     boost::optional<std::vector<std::string>> advertise = {})
    : _url(elle::sprintf("networks/%s/endpoints/%s/%x",
                         network.name, self.name, node_id))
    , _network(network)
    , _self(self)
  {
    bool v4 = elle::os::getenv("INFINIT_NO_IPV4", "").empty();
    bool v6 = elle::os::getenv("INFINIT_NO_IPV6", "").empty()
     && network.dht()->version >= elle::Version(0, 7, 0);
    Endpoints endpoints;
    if (advertise)
    {
      ELLE_TRACE("Adding hosts from advertise list");
      for (auto const& a: *advertise)
      {
        try
        {
          auto host = reactor::network::resolve_tcp(a, std::to_string(port));
          endpoints.addresses.push_back(host.address().to_string());
        }
        catch (reactor::network::ResolutionError const& e)
        {
          ELLE_LOG("failed to resolve %s: %s", a, e);
        }
      }
    }
    ELLE_TRACE("Establishing UPNP mapping");
    try
    {
      _upnp = reactor::network::UPNP::make();
      _upnp->initialize();
      _port_map_udp = _upnp->setup_redirect(reactor::network::Protocol::udt, port);
      _port_map_tcp = _upnp->setup_redirect(reactor::network::Protocol::tcp, port);
      ELLE_TRACE("got mappings: %s, %s", _port_map_udp, _port_map_tcp);
      if ( (v4 && _port_map_udp.external_host.find_first_of(':') == std::string::npos)
        || (v6 && _port_map_udp.external_host.find_first_of(':') != std::string::npos))
        endpoints.addresses.push_back(_port_map_udp.external_host);
    }
    catch (std::exception const& e)
    {
      ELLE_TRACE("UPNP eror: %s", e.what());
    }
    ELLE_TRACE("Obtaining public address from RDV");
    try
    {
      auto host = elle::os::getenv("INFINIT_RDV", "rdv.infinit.sh:7890");
      if (host.empty())
        throw std::runtime_error("RDV disabled");
      int port = 7890;
      auto p = host.find_last_of(':');
      if ( p!= host.npos)
      {
        port = std::stoi(host.substr(p+1));
        host = host.substr(0, p);
      }
      reactor::network::RDVSocket socket;
      socket.close();
      socket.bind(boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 0));
      reactor::Thread poller("poll", [&]
      {
        while (true)
        {
          elle::Buffer buf;
          buf.size(5000);
          boost::asio::ip::udp::endpoint ep;
          socket.receive_from(reactor::network::Buffer(buf.mutable_contents(),
                                                       buf.size()), ep);
        }
      });
      elle::SafeFinally spoll([&] {
          poller.terminate_now();
      });
      socket.rdv_connect("ip-fetcher", host, port, 5_sec);
      poller.terminate_now();
      spoll.abort();
      ELLE_TRACE("RDV gave endpoint %s", socket.public_endpoint());
      if (socket.public_endpoint().port())
      {
        auto addr = socket.public_endpoint().address();
        if ( (addr.is_v4() && v4) || (addr.is_v6() && v6))
          endpoints.addresses.push_back(addr.to_string());
      }
    }
    catch (std::exception const& e)
    {
      ELLE_TRACE("RDV error: %s", e.what());
    }
    ELLE_TRACE("Pushing endpoints");

    for (auto const& itf: elle::network::Interface::get_map(
           elle::network::Interface::Filter::only_up |
           elle::network::Interface::Filter::no_loopback |
           elle::network::Interface::Filter::no_autoip))
    {
      if (itf.second.ipv4_address.size() > 0 && v4)
        endpoints.addresses.push_back(itf.second.ipv4_address);
      if (v6) for (auto const& addr: itf.second.ipv6_address)
        endpoints.addresses.push_back(addr);
    }
    endpoints.port = port;
    beyond_push(this->_url, std::string("endpoints for"),
                network.name, endpoints, self, false);
  }

  ~InterfacePublisher()
  {
    beyond_delete(this->_url, "endpoints for", this->_network.name, _self);
  }

  ELLE_ATTRIBUTE(std::string, url);
  ELLE_ATTRIBUTE(infinit::Network const&, network);
  ELLE_ATTRIBUTE(infinit::User, self);
  ELLE_ATTRIBUTE(std::shared_ptr<reactor::network::UPNP>, upnp);
  ELLE_ATTRIBUTE(reactor::network::PortMapping, port_map_tcp);
  ELLE_ATTRIBUTE(reactor::network::PortMapping, port_map_udp);
};

inline
void
beyond_fetch_endpoints(infinit::Network const& network,
                       infinit::model::NodeLocations& hosts)
{
  reactor::http::Request r(
    elle::sprintf("%s/networks/%s/endpoints", beyond(), network.name));
  reactor::wait(r);
  if (r.status() != reactor::http::StatusCode::OK)
  {
    throw elle::Error(
      elle::sprintf("unexpected HTTP error %s fetching endpoints for \"%s\"",
                    r.status(), network.name));
  }
  auto json = boost::any_cast<elle::json::Object>(elle::json::read(r));
  for (auto const& user: json)
  {
    try
    {
      for (auto const& node: boost::any_cast<elle::json::Object>(user.second))
      {
        infinit::model::Address uuid =
          infinit::model::Address::from_string(node.first.substr(2));
        elle::serialization::json::SerializerIn s(node.second, false);
        auto endpoints = s.deserialize<Endpoints>();
        infinit::model::Endpoints eps;
        for (auto const& addr: endpoints.addresses)
          eps.emplace_back(boost::asio::ip::address::from_string(addr),
                           endpoints.port);
        hosts.emplace_back(uuid, std::move(eps));
      }
    }
    catch (std::exception const& e)
    {
      ELLE_WARN("Exception parsing peer endpoints: %s", e.what());
    }
  }
  report_action("fetched", "endpoints for", network.name);
}

namespace infinit
{
  inline
  Drive
  Infinit::drive_fetch(std::string const& name)
  {
    return beyond_fetch<Drive>("drive", name);
  }

  std::unique_ptr<std::istream>
  commands_input(boost::program_options::variables_map const& args);

  model::NodeLocations
  hook_peer_discovery(model::doughnut::Doughnut& model, std::string file);
}

#ifdef INFINIT_MACOSX
# define SXA_EXTRA ,0
#else
# define SXA_EXTRA
#endif

reactor::Thread::unique_ptr
make_stat_update_thread(infinit::User const& self,
                        infinit::Network& network,
                        infinit::model::doughnut::Doughnut& model);
#ifdef INFINIT_MACOSX
# define SXA_EXTRA ,0
#else
# define SXA_EXTRA
#endif

static std::string _hub_salt = "@a.Fl$4'x!";

struct LoginCredentials
{
  LoginCredentials(std::string const& name,
                   std::string const& password_hash,
                   std::string const& password = "")
    : name(name)
    , password_hash(password_hash)
    , password(password)
  {}

  LoginCredentials(elle::serialization::SerializerIn& s)
    : name(s.deserialize<std::string>("name"))
    , password_hash(s.deserialize<std::string>("password_hash"))
    , password(s.deserialize<std::string>("password"))
  {}

  std::string name;
  std::string password_hash;
  std::string password;
};

DAS_MODEL(LoginCredentials, (name, password_hash, password), DasLoginCredentials)

template <typename T>
elle::json::Json
beyond_login(std::string const& name,
             T const& o)
{
  reactor::http::Request::Configuration c;
  c.header_add("Content-Type", "application/json");
  reactor::http::Request r(elle::sprintf("%s/users/%s/login", beyond(), name),
                           reactor::http::Method::POST, std::move(c));
  elle::serialization::json::serialize(o, r, false);
  r.finalize();
  if (r.status() != reactor::http::StatusCode::OK)
  {
    read_error<BeyondError>(r, "login", name);
  }

  return elle::json::read(r);
}
