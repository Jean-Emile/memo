#include <time.h>

#include <boost/algorithm/string.hpp>
#include <boost/filesystem/fstream.hpp>
#include <boost/program_options.hpp>

#include <elle/Error.hh>
#include <elle/Exit.hh>
#include <elle/With.hh>
#include <elle/cast.hh>
#include <elle/format/base64url.hh>
#include <elle/network/Interface.hh>
#include <elle/os/environ.hh>
#include <elle/system/home_directory.hh>
#include <elle/system/username.hh>
#include <elle/json/exceptions.hh>

#include <das/model.hh>
#include <das/serializer.hh>

#include <reactor/http/Request.hh>

#include <cryptography/hash.hh>
#include <cryptography/rsa/KeyPair.hh>

#include <reactor/filesystem.hh>
#include <reactor/scheduler.hh>
#include <reactor/thread.hh>

#include <infinit/filesystem/filesystem.hh>
#include <infinit/model/doughnut/Local.hh>
#include <infinit/model/doughnut/Doughnut.hh>
#include <infinit/model/doughnut/consensus/Paxos.hh>
#include <infinit/overlay/kelips/Kelips.hh>
#include <infinit/storage/Async.hh>
#include <infinit/storage/Cache.hh>
#include <infinit/version.hh>

std::string program;

struct Credentials
{
  std::string uid;
  std::string display_name;
  std::string token;
  std::string refresh_token;
};

class CommandLineError
  : public elle::Error
{
public:
  template <typename ... Args>
  CommandLineError(Args&& ... args)
    : elle::Error(std::forward<Args>(args)...)
  {}
};

class MissingResource
  : public elle::Error
{
public:
  template <typename ... Args>
  MissingResource(Args&& ... args)
    : elle::Error(std::forward<Args>(args)...)
  {}
};

class MissingLocalResource
  : public MissingResource
{
public:
  template <typename ... Args>
  MissingLocalResource(Args&& ... args)
    : MissingResource(std::forward<Args>(args)...)
  {}
};

class ResourceAlreadyFetched
  : public elle::Error
{
public:
  template <typename ... Args>
  ResourceAlreadyFetched(Args&& ... args)
    : elle::Error(std::forward<Args>(args)...)
  {}
};

void
not_found(std::string const& name,
          std::string const& type)
{
  std::cerr <<
    elle::sprintf("%s %s not found on the Hub", type, name) << std::endl;
}

DAS_MODEL(Credentials,
          (uid, display_name, token, refresh_token),
          DasCredentials);
DAS_MODEL_DEFAULT(Credentials, DasCredentials);
DAS_MODEL_SERIALIZE(Credentials);

struct Mode
{
  typedef
    std::function<void (boost::program_options::variables_map const&)> Action;

  Mode(
    std::string name_,
    std::string description_,
    Action action_,
    std::string help = {},
    std::vector<boost::program_options::option_description> options = {},
    std::vector<boost::program_options::options_description> extra_options = {}
    )
    : name(std::move(name_))
    , description(std::move(description_))
    , action(std::move(action_))
    , help_complement(std::move(help))
    , options(this->description)
  {
    boost::program_options::options_description mode_options(
      elle::sprintf("%s%s options",
                    (char)toupper(this->name[0]),
                    this->name.substr(1)));
    for (auto const& option: options)
      mode_options.add(
        boost::shared_ptr<boost::program_options::option_description>
        (new boost::program_options::option_description(std::move(option))));
    this->options.add(mode_options);
    for (auto const& extra: extra_options)
      this->options.add(extra);
  }

  void
  help(std::ostream& output) const
  {
    output << "Usage: " << program
           << " --" << this->name;
    if (!this->help_complement.empty())
      output << " " << this->help_complement;
    output << " [OPTIONS...]" << std::endl;
    output << std::endl;
    output << this->options;
    output << std::endl;
  }

  std::string name;
  std::string description;
  Action action;
  std::string help_complement;
  boost::program_options::options_description options;
};
typedef std::vector<Mode> Modes;

boost::program_options::variables_map
parse_args(boost::program_options::options_description const& options,
           std::vector<std::string> const& args,
           std::string const& positional_arg)
{
  auto parser = boost::program_options::command_line_parser(args);
  boost::program_options::positional_options_description p;
  p.add(positional_arg.c_str(), -1);
  parser.options(options).positional(p);
  boost::program_options::variables_map res;
  auto parsed = parser.run();
  boost::program_options::store(parsed, res);
  boost::program_options::notify(res);
  return res;
}

bool script_mode = false;

namespace infinit
{
  int
  main(std::string desc,
       Modes const& modes,
       int argc,
       char** argv,
       boost::optional<std::string> positional_arg = {})
  {
    try
    {
      reactor::Scheduler sched;
      reactor::Thread main_thread(
        sched,
        "main",
        [&sched, &modes, &desc, argc, argv, &positional_arg]
        {
          ELLE_TRACE("parse command line")
          {
            using namespace boost::program_options;
            options_description mode_options("Modes");
            for (auto const& mode: modes)
              mode_options.add_options()(mode.name.c_str(),
                                         mode.description.c_str());
            options_description options(desc);
            options.add(mode_options);
            options_description misc("Miscellaneous");
            misc.add_options()
              ("help,h", "display the help")
              ("script,s", "silence all extraneous human friendly messages")
              ("version,v", "display version")
            ;
            options.add(misc);
            variables_map vm;
            try
            {
              auto parser = command_line_parser(argc, argv);
              parser.options(options);
              parser.allow_unregistered();
              auto parsed = parser.run();
              store(parsed, vm);
              notify(vm);
              if (vm.count("version"))
              {
                std::cout << INFINIT_VERSION << std::endl;
                throw elle::Exit(0);
              }
              script_mode = vm.count("script");
              bool help = vm.count("help");
              Mode const* mode = nullptr;
              std::vector<std::string> args;
              for (auto const& m: modes)
                if (vm.count(m.name))
                  if (!mode)
                    mode = &m;
                  else if (mode->name == "fetch" || mode->name == "push")
                  {
                    args.push_back("--" + mode->name);
                    mode = &m;
                  }
                  else
                    args.push_back("--" + m.name);
              if (!mode)
              {
                std::ostream& output = help ? std::cout : std::cerr;
                output << "Usage: " << program
                       << " MODE [OPTIONS...]" << std::endl;
                output << std::endl;
                output << options;
                output << std::endl;
                if (help)
                  throw elle::Exit(0);
                else
                  throw elle::Error("mode unspecified");
              }
              if (help)
              {
                mode->help(std::cout);
                return;
              }
              for (auto const& unrecognized:
                     collect_unrecognized(parsed.options, include_positional))
              {
                args.push_back(unrecognized);
              }
              try
              {
                mode->action(parse_args(mode->options, args,
                             (positional_arg ? positional_arg.get() : "name")));
              }
              catch (CommandLineError const&)
              {
                mode->help(std::cerr);
                throw;
              }
            }
            catch (invalid_command_line_syntax const& e)
            {
              throw elle::Error(
                elle::sprintf("command line error: %s", e.what()));
            }
          }
        });
      sched.run();
    }
    catch (elle::Exit const& e)
    {
      return e.return_code();
    }
    catch (elle::Exception const& e)
    {
      ELLE_TRACE("fatal error: %s\n%s", e.what(), e.backtrace());
      if (!elle::os::getenv("INFINIT_BACKTRACE", "").empty())
      {
        elle::fprintf(std::cerr, "%s: fatal error: %s\n%s\n", argv[0],
                      e.what(), e.backtrace());
      }
      else
      {
        elle::fprintf(std::cerr, "%s: fatal error: %s\n", argv[0], e.what());
      }
      return 1;
    }
    catch (std::exception const& e)
    {
      ELLE_TRACE("fatal error: %s", e.what());
      elle::fprintf(std::cerr, "%s: fatal error: %s\n", argv[0], e.what());
      return 1;
    }
    return 0;
  }

  inline
  boost::filesystem::path
  root_dir()
  {
    static auto const env = elle::os::getenv("INFINIT_HOME", "");
    static auto const res =
      env.empty() ? elle::system::home_directory() / ".infinit-drive"
                  : boost::filesystem::path(env);
    return res;
  }

  struct User
  {
    User(std::string name_, cryptography::rsa::KeyPair keys_)
      : name(std::move(name_))
      , public_key(std::move(keys_.K()))
      , private_key(std::move(keys_.k()))
    {}

    User(elle::serialization::SerializerIn& s)
      : name(s.deserialize<std::string>("name"))
      , public_key(s.deserialize<cryptography::rsa::PublicKey>("public_key"))
      , private_key(s.deserialize<boost::optional<
                      cryptography::rsa::PrivateKey>>("private_key"))
    {}

    infinit::cryptography::rsa::KeyPair
    keypair() const
    {
      if (!this->private_key)
      {
        throw elle::Error(
          elle::sprintf("user \"%s\" has no private key", this->name));
      }
      return infinit::cryptography::rsa::KeyPair(this->public_key,
                                                 this->private_key.get());
    }

    void
    serialize(elle::serialization::Serializer& s)
    {
      s.serialize("name", this->name);
      s.serialize("public_key", this->public_key);
      s.serialize("private_key", this->private_key);
    }

    static
    std::string
    uid(cryptography::rsa::PublicKey const& key)
    {
      auto serial = cryptography::rsa::publickey::der::encode(key);
      auto hash = cryptography::hash(serial, cryptography::Oneway::sha256);
      return elle::format::base64url::encode(hash).string().substr(0, 8);
    }

    std::string
    uid() const
    {
      return uid(this->public_key);
    }

    bool
    operator ==(User const& user) const
    {
      return this->name == user.name &&
        this->public_key == user.public_key;
    }

    std::string name;
    cryptography::rsa::PublicKey public_key;
    boost::optional<cryptography::rsa::PrivateKey> private_key;
  };

  struct NetworkDescriptor
  {
    NetworkDescriptor(
      std::string name_,
      std::unique_ptr<model::doughnut::consensus::Configuration> consensus_,
      std::unique_ptr<overlay::Configuration> overlay_,
      cryptography::rsa::PublicKey owner_)
      : name(std::move(name_))
      , consensus(std::move(consensus_))
      , overlay(std::move(overlay_))
      , owner(std::move(owner_))
    {}

    NetworkDescriptor(elle::serialization::SerializerIn& s)
      : name(s.deserialize<std::string>("name"))
      , consensus(s.deserialize<std::unique_ptr<
                  model::doughnut::consensus::Configuration>>("consensus"))
      , overlay(s.deserialize<std::unique_ptr<overlay::Configuration>>
                ("overlay"))
      , owner(s.deserialize<cryptography::rsa::PublicKey>("owner"))
    {}

    void
    serialize(elle::serialization::Serializer& s)
    {
      s.serialize("name", this->name);
      s.serialize("consensus", this->consensus);
      s.serialize("overlay", this->overlay);
      s.serialize("owner", this->owner);
    }

    std::string name;
    std::unique_ptr<model::doughnut::consensus::Configuration> consensus;
    std::unique_ptr<overlay::Configuration> overlay;
    cryptography::rsa::PublicKey owner;
    int replication_factor;
  };

  struct Network
  {
    Network()
      : name()
      , model()
    {}

    Network(elle::serialization::SerializerIn& s)
    {
      this->serialize(s);
    }

    void
    serialize(elle::serialization::Serializer& s)
    {
      s.serialize("name", this->name);
      s.serialize("model", this->model);
    }

    model::doughnut::Configuration*
    dht() const
    {
      return static_cast<model::doughnut::Configuration*>(this->model.get());
    }

    std::unique_ptr<model::doughnut::Doughnut>
    run(overlay::NodeEndpoints const& hosts = overlay::NodeEndpoints(),
        bool client = false,
        bool cache = false,
        boost::optional<int> cache_size = {},
        bool async_writes = false,
        bool async_consensus = false,
        bool cache_consensus = false)
    {
      boost::filesystem::path p = root_dir() / "cache" / name;
      return this->dht()->make(
        hosts, client, p, async_consensus, cache_consensus);
    }

    std::string name;
    std::unique_ptr<model::ModelConfig> model;
  };

  struct Volume
  {
    Volume() {};

    Volume(std::string name,
           boost::optional<std::string> mountpoint_,
           std::string network_)
      : name(name)
      , mountpoint(std::move(mountpoint_))
      , network(std::move(network_))
    {}

    Volume(elle::serialization::SerializerIn& s)
    {
      this->serialize(s);
    }

    void
    serialize(elle::serialization::Serializer& s)
    {
      s.serialize("name", this->name);
      if (s.out() && !this->mountpoint)
        s.serialize("mountpoint", this->mountpoint);
      s.serialize("network", this->network);
    }

    std::unique_ptr<reactor::filesystem::FileSystem>
    run(std::shared_ptr<model::doughnut::Doughnut> dht,
        boost::optional<std::string> mountpoint_ = {},
        boost::optional<std::string> volname_ = {})
    {
      auto fs = elle::make_unique<filesystem::FileSystem>(this->name, dht);
      auto driver =
        elle::make_unique<reactor::filesystem::FileSystem>(std::move(fs), true);
      boost::optional<boost::filesystem::path> mountpoint;
      if (mountpoint_)
        mountpoint = mountpoint_.get();
      else if (this->mountpoint)
        mountpoint = this->mountpoint.get();
      if (mountpoint)
      {
        try
        {
          create_directories(mountpoint.get());
        }
        catch (boost::filesystem::filesystem_error const&)
        {}
        driver->mount(mountpoint.get(), {"infinit-volume", "-o", "noatime", "-o", "hard_remove"});
      }
      return driver;
    }

    std::string name;
    boost::optional<std::string> mountpoint;
    model::Address root_address;
    std::string network;
  };

  struct Invitation
  {
    void
    serialize(elle::serialization::Serializer& s)
    {
      s.serialize("permissions", this->permissions);
      s.serialize("status", this->status);
      s.serialize("create_home", this->create_home);
    }

    // Values: "default", "r", "w", "x" and any combination of the 3.
    std::string permissions;
    // Values: "pending", "accepted" or "rejected".
    std::string status;
    bool create_home;
  };

  struct Drive
  {
    void
    serialize(elle::serialization::Serializer& s)
    {
      s.serialize("name", this->name);
      s.serialize("volume", this->volume);
      s.serialize("network", this->network);
      s.serialize("description", this->desc);
    }

    std::string name;
    std::string volume;
    std::string network;
    std::string desc;
  };

  class Infinit
  {
  public:
    std::string
    qualified_name(std::string const& network_name, User const& owner)
    {
      if (network_name.find("/") != std::string::npos)
        return network_name;
      else
        return elle::sprintf("%s/%s", owner.name, network_name);
    }

    std::string
    network_path_get(std::string const& name_, User const& owner)
    {
      std::string name = qualified_name(name_, owner);
      std::string path = this->_network_path(name).string();
      if (boost::filesystem::exists(path))
        return path;
      throw elle::Error(
        elle::sprintf("network \"%s\" not found", name));
    }

    Network
    network_get(std::string const& name_, User const& owner)
    {
      auto name = qualified_name(name_, owner);
      boost::filesystem::ifstream f;
      this->_open(f, this->_network_path(name), name, "network");
      auto res = elle::serialization::json::deserialize<Network>(f, false);
      if (!res.model)
      {
        throw elle::Error(
          elle::sprintf("you are not part of network %s, join it first",
                        name_));
      }
      return res;
    }

    std::vector<Network>
    networks_get() const
    {
      namespace boost_fs = boost::filesystem;
      std::vector<Network> res;
      for (boost_fs::recursive_directory_iterator it(this->_network_path());
           it != boost_fs::recursive_directory_iterator();
           ++it)
      {
        if (is_regular_file(it->status()))
        {
          boost_fs::ifstream f;
          this->_open(f, it->path(), "network", it->path().filename().string());
          res.push_back(
            elle::serialization::json::deserialize<Network>(f, false));
        }
      }
      return res;
    }

    NetworkDescriptor
    network_descriptor_get(std::string const& name_, User const& owner)
    {
      auto name = qualified_name(name_, owner);
      try
      {
        boost::filesystem::ifstream f;
        this->_open(f, this->_network_path(name), name, "network");
        elle::serialization::json::SerializerIn s(f, false);
        return s.deserialize<NetworkDescriptor>();
      }
      catch (elle::serialization::Error const&)
      {
        try
        {
          auto network = this->network_get(name_, owner);
          return NetworkDescriptor{
            network.name,
            std::move(network.dht()->consensus),
            std::move(network.dht()->overlay),
            std::move(network.dht()->owner)
          };
        }
        catch (elle::Error const&)
        {}
        throw;
      }
    }

    void
    network_save(Network const& network, bool overwrite = false)
    {
      boost::filesystem::ofstream f;
      this->_open(f, this->_network_path(network.name),
                  network.name, "network", overwrite);
      elle::serialization::json::SerializerOut s(f, false, true);
      s.serialize_forward(network);
    }

    void
    network_save(NetworkDescriptor const& network)
    {
      boost::filesystem::ofstream f;
      this->_open(f, this->_network_path(network.name),
                  network.name, "network");
      elle::serialization::json::SerializerOut s(f, false, true);
      s.serialize_forward(network);
    }

    void
    user_save(User const& user)
    {
      boost::filesystem::ofstream f;
      this->_open(f, this->_user_path(user.name), user.name, "user");
      elle::serialization::json::SerializerOut s(f, false, true);
      s.serialize_forward(user);
    }

    User
    user_get(boost::optional<std::string> user = {}) const
    {
      if (!user)
        user = elle::system::username();
      boost::filesystem::ifstream f;
      this->_open(f, this->_user_path(user.get()), user.get(), "user");
      elle::serialization::json::SerializerIn s(f, false);
      return s.deserialize<User>();
    }

    std::vector<User>
    users_get() const
    {
      namespace boost_fs = boost::filesystem;
      std::vector<User> res;
      for (boost_fs::recursive_directory_iterator it(this->_user_path());
           it != boost_fs::recursive_directory_iterator();
           ++it)
      {
        if (is_regular_file(it->status()))
        {
          boost_fs::ifstream f;
          this->_open(f, it->path(), "user", it->path().filename().string());
          res.push_back(elle::serialization::json::deserialize<User>(f, false));
        }
      }
      return res;
    }

    std::unique_ptr<storage::StorageConfig>
    storage_get(std::string const& name)
    {
      boost::filesystem::ifstream f;
      this->_open(f, this->_storage_path(name), name, "storage");
      elle::serialization::json::SerializerIn s(f, false);
      return s.deserialize<std::unique_ptr<storage::StorageConfig>>();
    }

    std::vector<std::string>
    storages_get()
    {
      namespace boost_fs = boost::filesystem;
      std::vector<std::string> res;
      for (boost_fs::recursive_directory_iterator it(this->_storage_path());
           it != boost_fs::recursive_directory_iterator();
           ++it)
      {
        if (is_regular_file(it->status()))
        {
          res.push_back(it->path().filename().string());
        }
      }
      return res;
    }

    void
    storage_save(std::string const& name, storage::StorageConfig const& storage)
    {
      boost::filesystem::ofstream f;
      this->_open(f, this->_storage_path(name), name, "storage");
      elle::serialization::json::SerializerOut s(f, false, true);
      s.serialize_forward(storage);
    }

    void
    storage_remove(std::string const& name)
    {
      auto path = this->_storage_path(name);
      if (!remove(path))
      {
        throw elle::Error(
          elle::sprintf("storage '%s' does not exist", name));
      }
    }

    Volume
    volume_get(std::string const& name)
    {
      boost::filesystem::ifstream f;
      this->_open(f, this->_volume_path(name), name, "volume");
      elle::serialization::json::SerializerIn s(f, false);
      return s.deserialize<Volume>();
    }

    void
    volume_save(Volume const& volume)
    {
      boost::filesystem::ofstream f;
      this->_open(f, this->_volume_path(volume.name), volume.name, "volume");
      elle::serialization::json::SerializerOut s(f, false, true);
      s.serialize_forward(volume);
    }

    std::vector<Volume>
    volumes_get() const
    {
      namespace boost_fs = boost::filesystem;
      std::vector<Volume> res;
      for (boost_fs::recursive_directory_iterator it(this->_volume_path());
           it != boost_fs::recursive_directory_iterator();
           ++it)
      {
        if (is_regular_file(it->status()))
        {
          boost_fs::ifstream f;
          this->_open(f, it->path(), "volume", it->path().filename().string());
          res.push_back(
            elle::serialization::json::deserialize<Volume>(f, false));
        }
      }
      return res;
    }

    void
    credentials_add(std::string const& name, Credentials const& a)
    {
      auto path = this->_credentials_path(name, elle::sprintf("%s", a.uid));
      boost::filesystem::ofstream f(path);
      if (!f.good())
      {
        throw elle::Error(
          elle::sprintf("unable to open %s for writing", path));
      }
      elle::serialization::json::serialize(a, f, false);
    }

    std::vector<Credentials>
    credentials(std::string const& name) const
    {
      std::vector<Credentials> res;
      auto const path = this->_credentials_path(name);
      boost::filesystem::directory_iterator const end;
      for (boost::filesystem::directory_iterator it(path);
           it != end;
           ++it)
      {
        if (is_regular_file(it->status()))
        {
          boost::filesystem::ifstream f(it->path());
          if (!f.good())
          {
            throw elle::Error(
              elle::sprintf("unable to open %s for reading", path));
          }
          res.push_back(
            elle::serialization::json::deserialize<Credentials>(f, false));
        }
      }
      return res;
    }

    Credentials
    credentials(std::string const& name, std::string const& uid) const
    {
      for (auto const& account: this->credentials(name))
      {
        if (account.display_name == uid || account.uid == uid)
          return account;
      }
      throw elle::Error(elle::sprintf("no such %s account: %s", name, uid));
    }

    void
    credentials_dropbox_add(Credentials const& a)
    {
      this->credentials_add("dropbox", a);
    }

    std::vector<Credentials>
    credentials_dropbox() const
    {
      return this->credentials("dropbox");
    }

    Credentials
    credentials_dropbox(std::string const& uid) const
    {
      return credentials("dropbox", uid);
    }

    void
    credentials_google_add(Credentials const& a)
    {
      this->credentials_add("google", a);
    }

    std::vector<Credentials>
    credentials_google() const
    {
      return this->credentials("google");
    }

    Credentials
    credentials_google(std::string const& uid) const
    {
      return credentials("google", uid);
    }

    boost::filesystem::path
    _credentials_path(std::string const& service) const
    {
      auto root = root_dir() / "credentials" / service;
      create_directories(root);
      return root;
    }

    boost::filesystem::path
    _credentials_path(std::string const& service, std::string const& name) const
    {
      return this->_credentials_path(service) / name;
    }

    boost::filesystem::path
    _network_path() const
    {
      auto root = root_dir() / "networks";
      create_directories(root);
      return root;
    }

    boost::filesystem::path
    _network_path(std::string const& name) const
    {
      return this->_network_path() / name;
    }

    boost::filesystem::path
    _storage_path() const
    {
      auto root = root_dir() / "storage";
      create_directories(root);
      return root;
    }

    boost::filesystem::path
    _storage_path(std::string const& name) const
    {
      return _storage_path() / name;
    }

    boost::filesystem::path
    _user_path() const
    {
      auto root = root_dir() / "users";
      create_directories(root);
      return root;
    }

    boost::filesystem::path
    _user_path(std::string const& name) const
    {
      return this->_user_path() / name;
    }

    boost::filesystem::path
    _volume_path() const
    {
      auto root = root_dir() / "volumes";
      create_directories(root);
      return root;
    }

    boost::filesystem::path
    _volume_path(std::string const& name) const
    {
      return this->_volume_path() / name;
    }

    void
    _open(boost::filesystem::ifstream& f,
          boost::filesystem::path const& path,
          std::string const& name,
          std::string const& type) const
    {
      f.open(path);
      if (!f.good())
      {
        throw MissingLocalResource(
          elle::sprintf("%s '%s' does not exist", type, name));
      }
    }

    void
    _open(boost::filesystem::ofstream& f,
          boost::filesystem::path const& path,
          std::string const& name,
          std::string const& type,
          bool overwrite = false)
    {
      create_directories(path.parent_path());
      if (!overwrite && exists(path))
      {
        throw ResourceAlreadyFetched(
          elle::sprintf("%s '%s' already exists", type, name));
      }
      f.open(path);
      if (!f.good())
      {
        throw elle::Error(
          elle::sprintf("unable to open '%s' for writing", path));
      }
    }

    boost::filesystem::path
    _drive_path(std::string const& name) const
    {
      auto root = root_dir() / "drives";
      create_directories(root);
      return root / name;
    }

    void
    drive_save(Drive const& drive)
    {
      boost::filesystem::ofstream f;
      this->_open(f, this->_drive_path(drive.name), drive.name, "drive");
      elle::serialization::json::SerializerOut s(f, false, true);
      s.serialize_forward(drive);
    }

    Drive
    drive_get(std::string const& name)
    {
      boost::filesystem::ifstream f;
      this->_open(f, this->_drive_path(name), name, "drive");
      elle::serialization::json::SerializerIn s(f, false);
      return s.deserialize<Drive>();
    }

    Drive
    drive_fetch(std::string const& name);
  };
}

class CommandLineSerializer
  : public elle::serialization::SerializerIn
{
public:
  typedef elle::serialization::SerializerIn Super;
  CommandLineSerializer(boost::program_options::variables_map const& vm)
    : Super(ELLE_SFINAE_INSTANCE(std::istream), false)
    , _variables(vm)
  {}

protected:
  boost::program_options::variables_map const& _variables;

  virtual
  void
  _serialize_array(std::string const& name,
                   int size, // -1 for in(), array size for out()
                   std::function<void ()> const& f)
  {
    ELLE_ABORT("not handled");
  }

  virtual
  void
  _serialize(std::string const& name, int64_t& v)
  {
    ELLE_ABORT("not handled");
  }

  virtual
  void
  _serialize(std::string const& name, uint64_t& v)
  {
    ELLE_ABORT("not handled");
  }

  virtual
  void
  _serialize(std::string const& name, int32_t& v)
  {
    ELLE_ABORT("not handled");
  }

  virtual
  void
  _serialize(std::string const& name, uint32_t& v)
  {
    ELLE_ABORT("not handled");
  }

  virtual
  void
  _serialize(std::string const& name, int8_t& v)
  {
    ELLE_ABORT("not handled");
  }

  virtual
  void
  _serialize(std::string const& name, uint8_t& v)
  {
    ELLE_ABORT("not handled");
  }

  virtual
  void
  _serialize(std::string const& name, double& v)
  {
    ELLE_ABORT("not handled");
  }

  virtual
  void
  _serialize(std::string const& name, bool& v)
  {
    ELLE_ABORT("not handled");
  }

  virtual
  void
  _serialize(std::string const& name, std::string& v)
  {
    v = this->_get(name).as<std::string>();
  }

  virtual
  void
  _serialize(std::string const& name, elle::Buffer& v)
  {
    ELLE_ABORT("not handled");
  }

  virtual
  void
  _serialize(std::string const& name, boost::posix_time::ptime& v)
  {
    ELLE_ABORT("not handled");
  }

  virtual
  void
  _serialize_option(std::string const& name,
                    bool present,
                    std::function<void ()> const& f)
  {
    if (this->_variables.count(name))
      f();
  }

private:
  boost::program_options::variable_value const&
  _get(std::string const& name)
  {
    auto count = this->_variables.count(name);
    if (!count)
      throw elle::Error(elle::sprintf("missing required '%s' option", name));
    if (count > 1)
      throw elle::Error(elle::sprintf("duplicate '%s' option", name));
    return this->_variables[name];
  }
};

boost::optional<std::string>
optional(boost::program_options::variables_map const& vm,
         std::string const& name)
{
  if (vm.count(name))
    return vm[name].as<std::string>();
  else
    return {};
}

template <typename T = std::string>
T
mandatory(boost::program_options::variables_map const& vm,
          std::string const& name,
          std::string const& desc)
{
  if (!vm.count(name))
  {
    throw CommandLineError(
      elle::sprintf("%s unspecified (use --%s)", desc, name));
  }
  return vm[name].as<T>();
}

template <typename T = std::string>
T
mandatory(boost::program_options::variables_map const& vm,
          std::string const& name)
{
  return mandatory<T>(vm, name, name);
}

template <>
std::vector<std::string>
mandatory<std::vector<std::string>>(
  boost::program_options::variables_map const& vm,
  std::string const& name,
  std::string const& desc)
{
  if (!vm.count(name))
  {
    throw CommandLineError(
      elle::sprintf("%s unspecified (use --%s [value ...])", desc, name));
  }
  return vm[name].as<std::vector<std::string>>();
}

bool
flag(boost::program_options::variables_map const& vm,
     std::string const& name)
{
  return vm.count(name) && vm[name].as<bool>();
}

bool
aliased_flag(boost::program_options::variables_map const& vm,
             std::vector<std::string> aliases)
{
  for (std::string const& alias: aliases)
  {
    if (vm.count(alias) && vm[alias].as<bool>())
      return true;
  }
  return false;
}

boost::program_options::option_description
option_output(std::string const& item)
{
  return boost::program_options::option_description(
    "output,o", boost::program_options::value<std::string>(),
    elle::sprintf("file to write the %s to (default: stdout)", item).c_str());
}

std::unique_ptr<std::ostream, std::function<void (std::ostream*)>>
get_output(boost::program_options::variables_map const& args)
{
  if (args.count("output"))
  {
    auto dest = args["output"].as<std::string>();
    if (dest != "-")
    {
      std::unique_ptr<std::ostream, std::function<void (std::ostream*)>> file
        (new std::ofstream(dest), [] (std::ostream* p) { delete p; });
      if (!file->good())
      {
        throw elle::Error(
          elle::sprintf("unable to open \"%s\" for writing", dest));
      }
      return file;
    }
  }
  return std::unique_ptr<std::ostream, std::function<void (std::ostream*)>>
    (&std::cout, [] (std::ostream*) {});
}

boost::program_options::option_description
option_input(std::string const& item)
{
  return boost::program_options::option_description(
    "input,i", boost::program_options::value<std::string>(),
    elle::sprintf("file to read the %s from (default: stdin)", item).c_str());
}

std::unique_ptr<std::istream, std::function<void (std::istream*)>>
get_input(boost::program_options::variables_map const& args)
{
  if (args.count("input"))
  {
    auto dest = args["input"].as<std::string>();
    if (dest != "-")
    {
      std::unique_ptr<std::istream, std::function<void (std::istream*)>> file
        (new std::ifstream(dest), [] (std::istream* p) { delete p; });
      if (!file->good())
      {
        throw elle::Error(
          elle::sprintf("unable to open \"%s\" for reading", dest));
      }
      return file;
    }
  }
  return std::unique_ptr<std::istream, std::function<void (std::istream*)>>
    (&std::cin, [] (std::istream*) {});
}

inline
std::string
get_username(boost::program_options::variables_map const& args,
             std::string const& name)
{
  auto opt = optional(args, name);
  return opt ? opt.get() : elle::system::username();
}

inline
std::string
get_name(boost::program_options::variables_map const& args)
{
  return get_username(args, "name");
}

DAS_MODEL_FIELDS(infinit::User, (name, public_key, private_key));

namespace infinit
{
  DAS_MODEL_DEFINE(User, (name, public_key, private_key), DasUser);
  DAS_MODEL_DEFINE(User, (name, public_key), DasPublicUser);
}

void
report(std::string const& msg)
{
  if (!script_mode)
  {
    elle::printf("%s%s.", (char)toupper(msg[0]), msg.substr(1));
    std::cout << std::endl;
  }
}

void
report_action(std::string const& action,
              std::string const& type,
              std::string const& name,
              boost::optional<std::string> where_ = {})
{
  std::string where = where_ ? elle::sprintf("%s ", where_.get()) : "";
  report(elle::sprintf("%s%s %s \"\%s\"", where, action, type, name));
}

void
report_created(std::string const& type, std::string const& name)
{
  report_action("created", type, name, std::string("locally"));
}

void
report_imported(std::string const& type, std::string const& name)
{
  report_action("imported", type, name);
}

void
report_action_output(std::ostream& output,
                     std::string const& action,
                     std::string const& type,
                     std::string const& name)
{
  if (&output != &std::cout)
    report_action(action, type, name);
}

void
report_exported(std::ostream& output,
                std::string const& type,
                std::string const& name)
{
  report_action_output(output, "exported", type, name);
}

std::string
beyond();

std::string
beyond()
{
  auto static const res = elle::os::getenv("INFINIT_BEYOND", "${beyond_host}");
  return res;
}

static
std::unordered_map<std::string, std::string>
signature_headers(
  reactor::http::Method method,
  std::string const& where,
  infinit::User const& self,
  boost::optional<std::stringstream const&> payload_ = {})
{
  using namespace infinit::cryptography;
  auto semi_colon_append = [](elle::Buffer& buffer, std::string const& str)
    {
      std::string res = elle::sprintf("%s;", str);
      return buffer.append(res.data(), res.size());
    };
  elle::Buffer string_to_sign = elle::Buffer();
  semi_colon_append(string_to_sign, elle::sprintf("%s", method));
  semi_colon_append(string_to_sign, where);
  elle::Buffer payload_hash;
  if (payload_)
  {
    auto payload = payload_.get().str();
    payload_hash = hash(
      elle::ConstWeakBuffer(payload.data(), payload.size()), Oneway::sha256);
  }
  else
  {
    payload_hash = hash(elle::ConstWeakBuffer(), Oneway::sha256);
  }
  auto encoded_hash = elle::format::base64::encode(payload_hash);
  semi_colon_append(string_to_sign, encoded_hash.string());
  auto now = std::to_string(time(0));
  string_to_sign.append(now.data(), now.size());
  auto signature = self.private_key->sign(
    string_to_sign,
    infinit::cryptography::rsa::Padding::pkcs1,
    infinit::cryptography::Oneway::sha256);
  auto encoded_signature = elle::format::base64::encode(signature);
  std::unordered_map<std::string, std::string> res = {
    { "infinit-signature", encoded_signature.string() },
    { "infinit-time", now },
  };
  return res;
}

template <typename T>
void
beyond_push(std::string const& where,
            std::string const& type,
            std::string const& name,
            T const& o,
            infinit::User const& self)
{
  using namespace infinit::cryptography;
  reactor::http::Request::Configuration c;
  c.header_add("Content-Type", "application/json");
  std::stringstream payload;
  elle::serialization::json::serialize(o, payload, false);
  auto headers = signature_headers(reactor::http::Method::PUT,
                                   where,
                                   self,
                                   payload);
  for (auto const& header: headers)
    c.header_add(header.first, header.second);
  reactor::http::Request r(elle::sprintf("%s/%s", beyond(), where),
                           reactor::http::Method::PUT, std::move(c));
  r << payload.str();
  r.finalize();
  reactor::wait(r);
  if (r.status() == reactor::http::StatusCode::Created)
    report_action("pushed", type, name, std::string("remotely"));
  else if (r.status() == reactor::http::StatusCode::OK)
    report_action("Already pushed", type, name);
  else if (r.status() == reactor::http::StatusCode::Conflict)
  {
    throw elle::Error(elle::sprintf(
      "%s \"%s\" already exists with a different key", type, name));
  }
  else if (r.status() == reactor::http::StatusCode::Not_Found)
  {
    try
    {
      auto json = boost::any_cast<elle::json::Object>(elle::json::read(r));
      auto error = boost::any_cast<std::string>(json["error"]);
      throw MissingResource(error);
    }
    catch(elle::json::ParseError const&)
    {
      throw elle::Error(
        elle::sprintf("unexpected HTTP error %s pushing %s",
                      r.status(), type));
    }
  }
  else
  {
    throw elle::Error(
      elle::sprintf("unexpected HTTP error %s pushing %s",
                    r.status(), type));
  }
}

template <typename T>
void
beyond_push(std::string const& type, std::string const& name, T const& o,
  infinit::User const& self)
{
  beyond_push(elle::sprintf("%ss/%s", type, name), type, name, o, self);
}

// FIXME: Workaround used to handle objects that have had their copy
// constructor deleted. See infinit-network.cc:fetch(), NetworkDescriptor.
// Remove when serialization does not require copy.
elle::json::Json
beyond_fetch_json(std::string const& where,
                  std::string const& type,
                  std::string const& name,
                  boost::optional<infinit::User const&> self = {},
                  bool output_report_action = true)
{
  reactor::http::Request::Configuration c;
  if (self)
  {
    auto headers = signature_headers(reactor::http::Method::GET,
                                     where,
                                     self.get());
    for (auto const& header: headers)
      c.header_add(header.first, header.second);
  }
  reactor::http::Request r(elle::sprintf("%s/%s", beyond(), where),
                           reactor::http::Method::GET,
                           std::move(c));
  reactor::wait(r);
  if (r.status() == reactor::http::StatusCode::OK)
  {
    if (output_report_action)
      report_action("fetched", type, name);
  }
  else if (r.status() == reactor::http::StatusCode::Not_Found)
  {
    throw elle::Error(
      elle::sprintf("%s \"%s\" not found", type, name));
  }
  else
  {
    throw elle::Error(
      elle::sprintf("unexpected HTTP error %s fetching %s",
                    r.status(), type));
  }
  return elle::json::read(r);
}

template <typename T>
T
beyond_fetch(std::string const& where,
             std::string const& type,
             std::string const& name,
             boost::optional<infinit::User const&> self = {},
             bool output_report_action = true)
{
  auto json = beyond_fetch_json(where, type, name, self, output_report_action);
  elle::serialization::json::SerializerIn input(json, false);
  return input.deserialize<T>();
}

template <typename T>
T
beyond_fetch(std::string const& type,
             std::string const& name)
{
  return beyond_fetch<T>(elle::sprintf("%ss/%s", type, name), type, name);
}

void
beyond_delete(std::string const& where,
              std::string const& type, std::string const& name,
              infinit::User const& self)
{
  reactor::http::Request::Configuration c;
  auto headers = signature_headers(reactor::http::Method::DELETE,
                                   where,
                                   self);
  for (auto const& header: headers)
    c.header_add(header.first, header.second);
  reactor::http::Request r(elle::sprintf("%s/%s", beyond(), where),
                           reactor::http::Method::DELETE,
                           std::move(c));
  r.finalize();
  reactor::wait(r);
  if (r.status() == reactor::http::StatusCode::OK)
    report_action("deleted", type, name, std::string("remotely"));
  else if (r.status() == reactor::http::StatusCode::Not_Found)
    throw MissingResource(elle::sprintf("%s %s does not exists on Hub",
                                        type,
                                        name));
  else
  {
    throw elle::Error(
      elle::sprintf("unexpected HTTP error %s deleting %s \"%s\"",
                    r.status(), type, name));
  }
}

void
beyond_delete(std::string const& type, std::string const& name,
              infinit::User const& self)
{
  beyond_delete(elle::sprintf("%ss/%s", type, name), type, name, self);
}

boost::program_options::option_description option_owner(
  "as,a", boost::program_options::value<std::string>(),
  "user to run commands as (default: system user)");

inline
static
infinit::User
self_user(infinit::Infinit const& ifnt,
          boost::program_options::variables_map const& args)
{
  static auto const env  = elle::os::getenv("INFINIT_USER", "");
  auto as = optional(args, option_owner.long_name());
  if (!as && !env.empty())
    as = env;
  auto res = ifnt.user_get(as);
  if (!res.private_key)
  {
    throw elle::Error(
      elle::sprintf("user \"%s\" has no private key", res.name));
  }
  return res;
}

struct Endpoints
{
  std::vector<std::string> addresses;
  int port;
};

DAS_MODEL(Endpoints, (addresses, port), DasEndpoints);
DAS_MODEL_DEFAULT(Endpoints, DasEndpoints);
DAS_MODEL_SERIALIZE(Endpoints);

class InterfacePublisher
{
public:
  friend class elle::With<InterfacePublisher>;
private:
  InterfacePublisher(infinit::Network const& network,
                     infinit::User const& self,
                     infinit::model::Address const& node_id,
                     int port)
    : _url(elle::sprintf("networks/%s/endpoints/%s/%s",
                         network.name, self.name, node_id))
    , _network(network)
    , _self(self)
  {
    Endpoints endpoints;
    for (auto const& itf: elle::network::Interface::get_map(
           elle::network::Interface::Filter::only_up |
           elle::network::Interface::Filter::no_loopback |
           elle::network::Interface::Filter::no_autoip))
      if (itf.second.ipv4_address.size() > 0)
        endpoints.addresses.push_back(itf.second.ipv4_address);
    endpoints.port = port;
    beyond_push(this->_url, "endpoints for", network.name, endpoints, self);
  }

  ~InterfacePublisher()
  {
    beyond_delete(this->_url, "endpoints for", this->_network.name, _self);
  }

  ELLE_ATTRIBUTE(std::string, url);
  ELLE_ATTRIBUTE(infinit::Network const&, network);
  ELLE_ATTRIBUTE(infinit::User, self);
};

void
beyond_fetch_endpoints(infinit::Network const& network,
                       std::unordered_map<infinit::model::Address,
                                          std::vector<std::string>>& hosts)
{
  reactor::http::Request r(
    elle::sprintf("%s/networks/%s/endpoints", beyond(), network.name));
  reactor::wait(r);
  if (r.status() == reactor::http::StatusCode::OK)
    report_action("fetched", "enpoints for", network.name);
  else
  {
    throw elle::Error(
      elle::sprintf("unexpected HTTP error %s fetching endpoints for \"%s\"",
                    r.status(), network.name));
  }
  auto json = boost::any_cast<elle::json::Object>(elle::json::read(r));
  for (auto const& user: json)
  {
    try
    {
      for (auto const& node: boost::any_cast<elle::json::Object>(user.second))
      {
        infinit::model::Address uuid =
          infinit::model::Address::from_string(node.first.substr(2));
        elle::serialization::json::SerializerIn s(node.second, false);
        auto endpoints = s.deserialize<Endpoints>();
        std::vector<std::string> addresses;
        for (auto const& addr: endpoints.addresses)
          addresses.push_back(elle::sprintf("%s:%s", addr, endpoints.port));
        hosts[uuid] = addresses;
      }
    }
    catch (std::exception const& e)
    {
      ELLE_WARN("Exception parsing peer endpoints: %s", e);
    }
  }
}

namespace infinit
{
  Drive
  Infinit::drive_fetch(std::string const& name)
  {
    return beyond_fetch<Drive>("drive", name);
  }
}
