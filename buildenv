#!/usr/bin/env python3

import collections
import datetime
import json
import os.path
import pickle
import sh
import shutil
import sys

SELF = os.path.realpath(sys.argv[0])
ROOT = os.path.dirname(SELF)

def json_converter(o):
  if isinstance(o, datetime.datetime):
    return o.isoformat()
  raise TypeError('%s is not JSON serializable' % o)

def copy(f, t):
  shutil.copytree(f, t)

def mv(f, t):
  os.rename(f, t)

def mkpath(p):
  try:
    os.makedirs(p)
  except OSError as e:
    if e.args[0] != 17: # EEXIST
      raise

def rm(p):
  try:
    if not os.path.isdir(p) or os.path.islink(p):
      os.unlink(p)
    else:
      shutil.rmtree(p)
  except OSError as e:
    if e.args[0] != 2: # ENOENT
      raise


class CLError(Exception):
  pass

class State:

  def __init__(self):
    self.__parser = self.__options_parser()
    self.__opts = self.__parser.parse_args()
    self.__branch = self.__opts.branch
    self.__git = None

  @property
  def state_path(self):
    return '%s/.state' % self.__opts.build_trees_root

  def __enter__(self):
    mkpath(self.__opts.build_trees_root)
    try:
      with open(self.state_path, 'rb') as f:
        self.__state = pickle.load(f)
      if self.__state is None:
        self.__state = {}
    except OSError:
      self.__state = {}
    return self

  def __exit__(self, t, v, tb):
    if not self.__opts.dry_run and t is None:
      tmp = '%s.tmp' % self.state_path
      try:
        with open(tmp, 'wb') as f:
          pickle.dump(self.__state, f)
      except:
        rm(tmp)
        raise
      else:
        mv(tmp, self.state_path)

  def __options_parser(self):
    import argparse
    # Parse options
    parser = argparse.ArgumentParser(add_help = False,
                                     description = 'To infinity!')
    parser.add_argument('-h', '--help',
                        action = 'help',
                        default = argparse.SUPPRESS,
                        help = 'Show this help message and exit',
    )
    parser.add_argument('-b', '--branch',
                        type = str,
                        help = 'Built branch',
    )
    parser.add_argument('-B', '--build-trees-root',
                        type = str,
                        default = '%s/_builds' % ROOT,
                        help = 'Build trees root directory',
    )
    parser.add_argument('-p', '--pick-build-tree',
                        action = 'store_true',
                        help = 'Pick adequate build tree',
    )
    parser.add_argument('-l', '--link-build-tree',
                        type = str,
                        help = 'Create symlink to picked build tree',
    )
    parser.add_argument('-s', '--show-build-tree',
                        action = 'store_true',
                        help = 'Pick adequate build tree',
    )
    parser.add_argument('-S', '--source-tree',
                        type = str,
                        default = ROOT,
                        help = 'Source tree location',
    )
    parser.add_argument('-d', '--dry-run',
                        action = 'store_true',
                        help = 'Do not modify anything',
    )
    return parser

  @property
  def parser(self):
    return self.__parser

  @property
  def source_tree(self):
    return self.__opts.source_tree

  @property
  def git(self):
    if self.__git is None:
      self.__git = sh.git.bake(_cwd = self.source_tree,
                               _tty_in = False,
                               _tty_out = False)
    return self.__git

  @property
  def branch(self):
    if self.__branch is None:
      self.__branch = self.git(
        'rev-parse', '--abbrev-ref', 'HEAD').strip()
    return self.__branch

  def run(self):
    if self.__opts.pick_build_tree:
      tree = self.pick_build_tree()
      symlink = self.__opts.link_build_tree
      if symlink is not None:
        rm(symlink)
        os.symlink(tree['path'], symlink)
      return tree
    elif self.__opts.show_build_tree:
      return self.show_build_tree()
    else:
      raise CLError('specify an action')

  def pick_build_tree(self):
    state = self.__state
    build_trees = state.setdefault('build-trees', {})
    branch = self.branch
    current_rev = self.git('rev-parse', 'HEAD').strip()
    previous = build_trees.get(branch)
    if previous is not None:
      if os.path.exists(previous['path']):
        previous['rev'] = current_rev
        previous['last_use'] = datetime.datetime.utcnow()
        return {
           'status': 'existing build tree',
           'path': previous['path'],
           'rev': previous['rev'],
         }
      else:
        del build_trees[branch]
        previous = None
    path = '%s/%s' % (self.__opts.build_trees_root, branch)
    clone_d = None
    clone = None
    clone_branch = None
    for b, tree in build_trees.items():
      rev = tree['rev']
      base = self.git('merge-base', rev, 'origin/%s' % branch).strip()
      def distance(r):
        return int(sh.wc(self.git('log', '%s..%s' % (base, r),
                                  '--pretty=oneline'), '-l'))
      d = distance('origin/%s' % branch) + distance(rev)
      if clone is None or d < clone_d:
        clone = tree
        clone_branch = b
        clone_d = d
    build_trees[branch] = {
      'creation': datetime.datetime.utcnow(),
      'last_use': datetime.datetime.utcnow(),
      'path': path,
      'rev': current_rev,
    }
    if clone is not None:
      if not self.__opts.dry_run:
        tmp = '%s.tmp' % path
        try:
          copy(tree['path'], tmp)
          fr = os.path.realpath(tree['path'])
          fr = '%s/.drake/%s' % (tmp, fr)
          to = os.path.realpath(path)
          to = '%s/.drake/%s' % (tmp, to)
          mkpath(os.path.dirname(to))
          rm(to)
          mv(fr, to)
        except:
          rm(tmp)
          raise
        else:
          mv(tmp, path)
      return {
        'status': 'cloned from %s' % clone_branch,
        'path': path,
        'rev': tree['rev'],
      }
    else:
      if not self.__opts.dry_run:
        mkpath(path)
      return {
        'status': 'new build tree',
        'path': path,
        'rev': None,
      }

  def show_build_tree(self):
    build_trees = self.__state.setdefault('build-trees', {})
    previous = build_trees.get(self.branch)
    if previous is not None:
      return previous
    else:
      return None

try:
  with State() as state:
    json.dump(collections.OrderedDict(state.run()), sys.stdout,
              default = json_converter)
    print()
except CLError as e:
  state.parser.print_usage(file = sys.stderr)
  print('%s: command line error: %s' % (sys.argv[0], e),
        file = sys.stderr)
  exit(1)
except Exception as e:
  print('%s: fatar error: %s' % (sys.argv[0], e), file = sys.stderr)
  raise
  exit(1)
