import drake
import drake.cxx
import drake.debian
import drake.git
import drake.python
import drake.valgrind

import os
import shutil

from itertools import chain

git = None

elle = None
installed_binaries = []

rule_build = None
rule_check = None
rule_install = None
rule_tests = None

name_regex = '^[-a-z0-9._]+$'

with open(str(drake.path_source('elle/drake-utils.py')), 'r') as f:
  exec(f.read(), globals(), globals())

def configure(
    cxx_toolkit = None,
    cxx_config = drake.cxx.Config(),
    production_build = False,
    beyond_host = 'https://beyond.infinit.io',
    boost = None,
    prefix = '/usr',
    valgrind = None,
    valgrind_tests = False,
    python = None,
    fuse = None,
    codesign = False,
    beyond = True,
):

  global rule_build, rule_check, rule_install, rule_tests
  rule_build = drake.Rule('build')
  rule_check = drake.Rule('check')
  rule_install = drake.Rule('install')
  rule_tests = drake.Rule('tests')
  rule_functional_tests = drake.Rule('functional/tests')
  rule_functional_check = drake.Rule('functional/check')

  class PatchAndInstall(drake.Install):
    def execute(self):
      if not super().execute():
        return False
      if cxx_toolkit.os == drake.os.macos and \
          cxx_toolkit.kind == drake.cxx.GccToolkit.Kind.gcc:
        def set_lib_id(path):
          subprocess.check_output([
            'install_name_tool',
            '-id',
            '@rpath/%s' % os.path.basename(str(path)),
            str(path)])

        def get_deps_fix_rpaths(path):
          os.chmod(str(path), 0o755)
          if 'dylib' in str(path):
            set_lib_id(path)
          otool_out = subprocess.check_output(['otool', '-L',  str(path)])
          otool_lines = otool_out.decode('utf-8').strip().split('\n')
          otool_lines = [
            x.replace('\t', '').split(' ')[0]
            for x in otool_lines[1:] if 'libstdc++' in x or 'libgcc_s' in x
          ]
          for l in otool_lines:
            drake.command([
              'install_name_tool', '-change',
              l, '@rpath/%s' % (os.path.basename(l)), str(path)
            ])
            dep_dir = os.path.normpath(
              os.path.join(os.path.dirname(str(path)), '..', 'lib'))
            dep_file = \
              os.path.normpath(os.path.join(dep_dir, os.path.basename(l)))
            if not os.path.exists(dep_dir):
              os.makedirs(dep_dir)
            if not os.path.exists(dep_file):
              import shutil
              shutil.copy(l, dep_dir)
              get_deps_fix_rpaths(drake.Path(dep_file))
              os.chmod(dep_file, 0o755)
              set_lib_id(dep_file)
              os.chmod(dep_file, 0o555)
          os.chmod(str(path), 0o555)

        path = self.target().path()
        get_deps_fix_rpaths(path)
      return True

  prefix = drake.Path(prefix)
  if prefix.relative:
    prefix = drake.path_build(prefix, absolute = True)

  cxx_config = drake.cxx.Config(cxx_config)
  cxx_config.warnings.parentheses = False
  cxx_config.warnings.sign_compare = drake.cxx.Config.Warnings.Error;
  if production_build:
    cxx_config.enable_optimization()
    cxx_config.define('INFINIT_PRODUCTION_BUILD')

  global git
  git = drake.git.Git()

  global elle
  elle = drake.include('elle',
                       production_build = production_build,
                       cxx_toolkit = cxx_toolkit,
                       cxx_config = cxx_config,
                       python3 = python,
                       fuse = fuse,
                       valgrind = valgrind,
                       prefix = False,
                       codesign = codesign)
  windows = elle.cxx_toolkit.os is drake.os.windows
  linux = elle.cxx_toolkit.os is drake.os.linux

  if not windows:
    dropbox_lib = drake.copy(elle.dropbox.lib_dynamic, 'lib',
                             strip_prefix = True)
    cryptography_lib = drake.copy(elle.cryptography.lib_dynamic, 'lib',
                                  strip_prefix = True)
    protocol_lib = drake.copy(elle.protocol.lib_dynamic, 'lib',
                              strip_prefix = True)
    reactor_lib = drake.copy(elle.reactor.lib_dynamic, 'lib',
                             strip_prefix = True)
    aws_lib = drake.copy(elle.aws.library, 'lib',
                         strip_prefix = True)
    elle_lib = drake.copy(elle.elle.lib_dynamic, 'lib',
                          strip_prefix = True)
  else:
    dropbox_lib = elle.dropbox.lib_static
    cryptography_lib = elle.cryptography.lib_static
    protocol_lib = elle.protocol.lib_static
    reactor_lib = elle.reactor.lib_static
    aws_lib = elle.aws.library
    elle_lib = elle.elle.lib_static

  athena_lib = drake.copy(elle.athena.lib_dynamic, 'lib',
                          strip_prefix = True)

  cxx_toolkit = elle.cxx_toolkit
  cxx_config += elle.config
  cxx_config += elle.dropbox.config
  cxx_config += elle.athena.config
  cxx_config.add_local_include_path('src')
  cxx_config.define('_FILE_OFFSET_BITS=64')

  if cxx_toolkit.os in [drake.os.macos] and cxx_toolkit.kind == drake.cxx.GccToolkit.Kind.clang:
    cxx_config.use_local_libcxx = True

  ## --------------- ##
  ## Infinit library ##
  ## --------------- ##

  cxx_config_infinit = drake.cxx.Config(cxx_config)

  cxx_config_infinit += elle.boost.config_system(link = False)
  if not windows:
    cxx_config_infinit.library_add(
      drake.copy(elle.boost.system_dynamic, 'lib', True))
  cxx_config_infinit += elle.boost.config_filesystem(link = False)
  if not windows:
    cxx_config_infinit.library_add(
      drake.copy(elle.boost.filesystem_dynamic, 'lib', True))
  cxx_config_infinit += elle.das.config

  class CxxVersionGenerator(VersionGenerator):
    def _variable(self, name, value):
      try:
        return '#define INFINIT_%s %s' % (name.upper(), int(value))
      except:
        return '#define INFINIT_%s "%s"' % (name.upper(), value)

  CxxVersionGenerator(drake.node('src/infinit/version.hh'), git)

  infinit_sources = drake.nodes(
    'src/infinit/RPC.hh',
    'src/infinit/RPC.hxx',
    'src/infinit/filesystem/filesystem.cc',
    'src/infinit/filesystem/filesystem.hh',
    'src/infinit/filesystem/AnyBlock.cc',
    'src/infinit/filesystem/AnyBlock.hh',
    'src/infinit/filesystem/Directory.cc',
    'src/infinit/filesystem/Directory.hh',
    'src/infinit/filesystem/File.cc',
    'src/infinit/filesystem/File.hh',
    'src/infinit/filesystem/FileHandle.cc',
    'src/infinit/filesystem/FileHandle.hh',
    'src/infinit/filesystem/FileData.hh',
    'src/infinit/filesystem/Node.cc',
    'src/infinit/filesystem/Node.hh',
    'src/infinit/filesystem/Symlink.cc',
    'src/infinit/filesystem/Symlink.hh',
    'src/infinit/filesystem/umbrella.hh',
    'src/infinit/filesystem/Unknown.cc',
    'src/infinit/filesystem/Unknown.hh',
    'src/infinit/filesystem/xattribute.cc',
    'src/infinit/filesystem/xattribute.hh',
    'src/infinit/model/Address.cc',
    'src/infinit/model/Address.hh',
    'src/infinit/model/MissingBlock.cc',
    'src/infinit/model/MissingBlock.hh',
    'src/infinit/model/Model.cc',
    'src/infinit/model/Model.hh',
    'src/infinit/model/Model.hxx',
    'src/infinit/model/User.hh',
    'src/infinit/model/blocks/ACLBlock.cc',
    'src/infinit/model/blocks/ACLBlock.hh',
    'src/infinit/model/blocks/Block.cc',
    'src/infinit/model/blocks/Block.hh',
    'src/infinit/model/blocks/ImmutableBlock.cc',
    'src/infinit/model/blocks/ImmutableBlock.hh',
    'src/infinit/model/blocks/MutableBlock.cc',
    'src/infinit/model/blocks/MutableBlock.hh',
    'src/infinit/model/blocks/ValidationResult.cc',
    'src/infinit/model/blocks/ValidationResult.hh',
    'src/infinit/model/blocks/fwd.hh',
    'src/infinit/model/doughnut/ACB.cc',
    'src/infinit/model/doughnut/ACB.hh',
    'src/infinit/model/doughnut/Async.cc',
    'src/infinit/model/doughnut/Async.hh',
    'src/infinit/model/doughnut/Cache.cc',
    'src/infinit/model/doughnut/Cache.hh',
    'src/infinit/model/doughnut/Conflict.cc',
    'src/infinit/model/doughnut/Conflict.hh',
    'src/infinit/model/doughnut/Consensus.cc',
    'src/infinit/model/doughnut/Consensus.hh',
    'src/infinit/model/doughnut/Doughnut.cc',
    'src/infinit/model/doughnut/Doughnut.hh',
    'src/infinit/model/doughnut/Local.cc',
    'src/infinit/model/doughnut/Local.hh',
    'src/infinit/model/doughnut/NB.cc',
    'src/infinit/model/doughnut/NB.hh',
    'src/infinit/model/doughnut/OKB.cc',
    'src/infinit/model/doughnut/OKB.hh',
    'src/infinit/model/doughnut/Passport.cc',
    'src/infinit/model/doughnut/Passport.hh',
    'src/infinit/model/doughnut/Peer.cc',
    'src/infinit/model/doughnut/Peer.hh',
    'src/infinit/model/doughnut/Remote.cc',
    'src/infinit/model/doughnut/Remote.hh',
    'src/infinit/model/doughnut/Remote.hxx',
    'src/infinit/model/doughnut/UB.cc',
    'src/infinit/model/doughnut/UB.hh',
    'src/infinit/model/doughnut/User.cc',
    'src/infinit/model/doughnut/User.hh',
    'src/infinit/model/doughnut/ValidationFailed.cc',
    'src/infinit/model/doughnut/ValidationFailed.hh',
    'src/infinit/model/doughnut/consensus/Paxos.cc',
    'src/infinit/model/doughnut/consensus/Paxos.hh',
    'src/infinit/model/faith/Faith.cc',
    'src/infinit/model/faith/Faith.hh',
    'src/infinit/model/paranoid/Paranoid.cc',
    'src/infinit/model/paranoid/Paranoid.hh',
    'src/infinit/overlay/Kalimero.cc',
    'src/infinit/overlay/Kalimero.hh',
    'src/infinit/overlay/Overlay.cc',
    'src/infinit/overlay/Overlay.hh',
    'src/infinit/overlay/Stonehenge.cc',
    'src/infinit/overlay/Stonehenge.hh',
    'src/infinit/overlay/kademlia/kademlia.cc',
    'src/infinit/overlay/kademlia/kademlia.hh',
    'src/infinit/overlay/kelips/Kelips.cc',
    'src/infinit/overlay/kelips/Kelips.hh',
    'src/infinit/serialization.cc',
    'src/infinit/serialization.hh',
    'src/infinit/smb/smb.cc',
    'src/infinit/storage/Adb.cc',
    'src/infinit/storage/Adb.hh',
    'src/infinit/storage/Async.cc',
    'src/infinit/storage/Async.hh',
    'src/infinit/storage/Cache.cc',
    'src/infinit/storage/Cache.hh',
    'src/infinit/storage/Collision.cc',
    'src/infinit/storage/Collision.hh',
    'src/infinit/storage/Crypt.cc',
    'src/infinit/storage/Crypt.hh',
    'src/infinit/storage/Dropbox.cc',
    'src/infinit/storage/Dropbox.hh',
    'src/infinit/storage/Filesystem.cc',
    'src/infinit/storage/Filesystem.hh',
    'src/infinit/storage/GoogleDrive.cc',
    'src/infinit/storage/GoogleDrive.hh',
    'src/infinit/storage/InsufficientSpace.cc',
    'src/infinit/storage/InsufficientSpace.hh',
    'src/infinit/storage/Key.hh',
    'src/infinit/storage/Latency.cc',
    'src/infinit/storage/Latency.hh',
    'src/infinit/storage/Memory.cc',
    'src/infinit/storage/Memory.hh',
    'src/infinit/storage/Mirror.cc',
    'src/infinit/storage/Mirror.hh',
    'src/infinit/storage/MissingKey.cc',
    'src/infinit/storage/MissingKey.hh',
    'src/infinit/storage/S3.cc',
    'src/infinit/storage/S3.hh',
    'src/infinit/storage/Storage.cc',
    'src/infinit/storage/Storage.hh',
    'src/infinit/storage/Strip.cc',
    'src/infinit/storage/Strip.hh',
    'src/infinit/storage/fwd.hh',

    'src/infinit/version.hh',
  )
  if not windows:
    infinit_sources += drake.nodes(
      'src/infinit/storage/sftp.cc',
      'src/infinit/storage/sftp.hh',
      )
  outguess_lib = drake.cxx.StaticLib('src/infinit/model/steg/outguess-0.2/outguess.a')
  jpeg_lib = drake.cxx.StaticLib('src/infinit/model/steg/outguess-0.2/jpeg-6b-steg/libjpeg.a')

  outguess_configure = drake.node('src/infinit/model/steg/outguess-0.2/configure')
  outguess_makefile = drake.node('src/infinit/model/steg/outguess-0.2/Makefile')

  if windows:
    cxx_config_infinit.lib('shlwapi')
    cxx_config_infinit.lib('ws2_32')
    cxx_config_infinit.lib('gdi32')
    cxx_config_infinit.lib('mswsock')
    cxx_config_infinit.lib('dbghelp')
    cxx_config_infinit.lib('iphlpapi')
    cxx_config_infinit.lib('crypt32')
    libtype = drake.cxx.StaticLib
  else:
    libtype = drake.cxx.DynLib
  infinit_lib = libtype(
    'lib/infinit',
    infinit_sources + [athena_lib,
                       cryptography_lib,
                       aws_lib,
                       protocol_lib,
                       dropbox_lib,
                       reactor_lib,
                       elle_lib
                       ],
    cxx_toolkit,
    cxx_config_infinit)
  rule_build << infinit_lib

  ## -------- ##
  ## Binaries ##
  ## -------- ##

  with drake.templating.Context(content = {
      'beyond_host': beyond_host,
      'name_regex': name_regex,
  }):
    drake.node('bin/main.hh.tmpl')

  drake.node('bin/password.hh')

  bin_cxx_config = drake.cxx.Config(cxx_config)
  bin_cxx_config += elle.das.config
  bin_cxx_config.add_local_include_path('bin')
  bin_cxx_config.lib_path_runtime('../lib')
  if not windows:
    bin_cxx_config.library_add(
        drake.copy(elle.boost.program_options_dynamic, 'lib', True))
    bin_cxx_config.library_add(
        drake.copy(elle.boost.filesystem_dynamic, 'lib', True))
    bin_cxx_config.library_add(
        drake.copy(elle.boost.regex_dynamic, 'lib', True))
    bin_cxx_config.library_add(
        drake.copy(elle.boost.system_dynamic, 'lib', True))
  else:
    bin_cxx_config.lib('shlwapi')
    bin_cxx_config.lib('ws2_32')
    bin_cxx_config.lib('gdi32')
    bin_cxx_config.lib('mswsock')
    bin_cxx_config.lib('dbghelp')
    bin_cxx_config.lib('iphlpapi')
    bin_cxx_config.lib('crypt32')
    bin_cxx_config.library_add(elle.boost.program_options_static)
    bin_cxx_config.library_add(elle.boost.regex_static)
    bin_cxx_config.use_whole_archive()
  # Ship libstdc++
  additional_libs = []
  if linux:
    output = subprocess.check_output(['ldconfig', '-p'])
    path = None
    searched_for = {'libstdc++', 'libgcc_s'}
    need_64 = cxx_toolkit.architecture == drake.architecture.x86_64
    for line in output.decode('utf-8').split('\n'):
      for searched in searched_for:
        if searched in line:
          if need_64 != ('x86-64' in line):
            continue
          path = drake.Path(line.split(' ')[-1])
          additional_libs.append(
            drake.copy(drake.cxx.DynLib(path), 'lib', strip_prefix = True))
          searched_for.remove(searched)
          break
      if not searched_for:
        break
    if searched_for:
      raise Exception('Unable to find %s with ldconfig -p' %
                      ', '.join(searched_for))
  # Build
  binaries_config = [
    ('doughnode', [], False),
    ('generatekeys', [], False),
    ('infinit', [], False),
    ('infinit-acl', [], True),
    ('infinit-credentials', [], not production_build),
    ('infinit-device', [], True),
    ('infinit-drive', [], True),
    ('infinit-network', [], True),
    ('infinit-passport', [], True),
    ('infinit-smb', [], False),
    ('infinit-storage', [], True),
    ('infinit-user', [], True),
    ('infinit-volume', [], True),
    ('infinit-webdav', [], False),
    ('infinit-fsck', [], False),
    ('s3fs', [aws_lib], False),
  ]
  if not windows:
    binaries_config.append(('sshfs', [], False))
  binaries = []
  global installed_binaries
  installed_binaries = []
  for name, libs, install in binaries_config:
    source = drake.node('bin/%s.cc' % name)
    bin = drake.cxx.Executable(
      'bin/%s' % name, [
        source,
        infinit_lib,
        elle_lib,
        reactor_lib,
        cryptography_lib
      ] + libs + additional_libs,
      cxx_toolkit,
      bin_cxx_config)
    rule_build << bin
    binaries.append(bin)
    if install:
      installed_binaries.append(bin)

  ## ----- ##
  ## Share ##
  ## ----- ##

  demo_home = drake.nodes(
    'demo-home/networks/infinit/demo',
    'demo-home/passports/infinit/demo/demo',
    'demo-home/users/demo',
    'demo-home/volumes/infinit/demo',
  )

  ## ------- ##
  ## Install ##
  ## ------- ##

  def install_nodes(where):
    where = drake.Path(where)
    yield from drake.copy(installed_binaries, where, None,
                          builder = PatchAndInstall)
    yield from drake.copy(
      demo_home, where / 'share/infinit/filesystem/test/home/', 'demo-home')

  rule_install << install_nodes(prefix)

  # man = drake.nodes(
  #   'share/man/man1/infinit.1',
  #   'share/man/man5/infinit.5',
  # )
  # rule_install << drake.install(man, prefix)

  ## ------ ##
  ## Debian ##
  ## ------ ##

  debian_nodes = install_nodes('debian/opt/infinit')
  git = drake.git.Git()
  with drake.templating.Context(content = {
      'version': git.description(),
      'version_major': git.version().split('.')[0],
      'version_minor': git.version().split('.')[1],
  }):
    drake.node('control.tmpl')
  debian_nodes = chain(
    debian_nodes,
    drake.copy(drake.nodes('control'), 'debian/DEBIAN'),
  )
  rule_debian = drake.Rule('debian')
  rule_debian << drake.debian.Packager(
    'infinit_%s_amd64.deb' % git.description(),
    debian_nodes, 'debian').package

  ## ------ ##
  ## Beyond ##
  ## ------ ##

  if elle.python3:
    bottle = drake.node('bottle/bottle.py')
    sendwithus = drake.python.Package(
      'sendwithus',
      'sendwithus_python',
      drake.nodes(
        'sendwithus_python/sendwithus/__init__.py',
        'sendwithus_python/sendwithus/encoder.py',
        'sendwithus_python/sendwithus/version.py',
      ),
    )
    if beyond:
      beyond = drake.include(
        'beyond',
        python = elle.python3,
        cryptography_python_module = elle.cryptography.python_module,
        sendwithus = sendwithus,
        prefix = prefix,
        git = git,
        bottle = bottle,
        PatchAndInstall = PatchAndInstall,
        name_regex = name_regex,
      )
      rule_check << beyond.rule_check
      for test_name in [
          'errors',
          'single-user-two-devices-shared-storage',
          #FIXME: 'flow',
          # Test clis.
          'device_cli',
          'user_cli',
          'network_cli',
          'passport_cli',
          'volume_cli',
          'drive_cli',
          'storage_cli',
      ]:
        test = drake.node('tests/functional/%s' % test_name)
        rule_functional_tests << test
        test.dependencies_add(installed_binaries)
        test.dependencies_add(beyond.package.nodes)
        runner = drake.Runner(
          exe = test,
          env = {
            'PYTHONPATH':
              drake.path_build('beyond/lib/python%s' % elle.python3.version)
          })
        rule_functional_check << runner.status
      rule_tests << rule_functional_tests
      rule_check << rule_functional_check
    website = drake.include(
      'website',
      python = elle.python3,
      prefix = prefix,
      git = git,
      bottle = bottle,
      sendwithus = sendwithus,
      PatchAndInstall = PatchAndInstall,
    )

  ## ----- ##
  ## Tests ##
  ## ----- ##

  cxx_config_tests = drake.cxx.Config(cxx_config)
  cxx_config_tests += elle.das.config
  cxx_config_tests.lib_path_runtime('../lib')
  cxx_config_tests.lib_path_runtime('../../lib') # For consensus/async test.
  cxx_config_tests += elle.boost.config_test(link = False)
  if not windows:
    cxx_config_tests.library_add(
      drake.copy(elle.boost.test_dynamic, 'lib', True))
    cxx_config_tests += elle.boost.config_system(link = False)
    cxx_config_tests.library_add(
      drake.copy(elle.boost.system_dynamic, 'lib', True))
    cxx_config_tests += elle.boost.config_filesystem(link = False)
    cxx_config_tests.library_add(
      drake.copy(elle.boost.filesystem_dynamic, 'lib', True))
  else:
    cxx_config_tests.lib('shlwapi')
    cxx_config_tests.lib('ws2_32')
    cxx_config_tests.lib('gdi32')
    cxx_config_tests.lib('mswsock')
    cxx_config_tests.lib('dbghelp')
    cxx_config_tests.lib('iphlpapi')
    cxx_config_tests.lib('crypt32')
    cxx_config_tests.library_add(elle.boost.program_options_static)
    cxx_config_tests.library_add(elle.boost.test_static)
    cxx_config_tests.use_whole_archive()
  tests_names = [
      'consensus/async',
      'doughnut',
      'faith',
      'rpc',
      'storage',
  ]
  if not windows:
    tests_names += ['filesystem']
  for test_name in tests_names:
    test = drake.cxx.Executable(
      'tests/%s' % test_name,
      [
        drake.node('tests/%s.cc' % test_name),
        infinit_lib,
        elle_lib,
        cryptography_lib,
        reactor_lib,
        protocol_lib,
      ],
      cxx_toolkit,
      cxx_config_tests)
    # filesystem requires 'infinit'.
    test.dependencies_add(binaries)
    rule_tests << test
    if valgrind_tests:
      runner = drake.valgrind.ValgrindRunner(
        exe = test, valgrind = valgrind)
    else:
      runner = drake.Runner(exe = test)
    runner.reporting = drake.Runner.Reporting.on_failure
    rule_check << runner.status
