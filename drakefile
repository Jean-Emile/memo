import drake
import drake.cxx
import drake.git
import drake.python
import drake.valgrind

import os
import shutil

git = None

elle = None
installed_binaries = []

rule_build = None
rule_install = None

with open(str(drake.path_source('elle/drake-utils.py')), 'r') as f:
  exec(f.read(), globals(), globals())

def configure(
    cxx_toolkit = None,
    cxx_config = drake.cxx.Config(),
    production_build = False,
    beyond_host = 'https://beyond.infinit.io',
    boost = None,
    prefix = '/usr',
    valgrind = None,
    valgrind_tests = False,
    python = None,
    fuse = None,
    codesign = False,
):

  class PatchAndInstall(drake.Install):
    def execute(self):
      if not super().execute():
        return False
      if cxx_toolkit.os == drake.os.macos and cxx_toolkit.kind == drake.cxx.GccToolkit.Kind.gcc:
        target_path =  str(self.target().path())
        output = subprocess.check_output(
          ['otool', '-L',  target_path])
        lines = output.decode('utf-8').strip().split('\n')
        lines = [
          x.replace('\t', '').split(' ')[0]
          for x in lines if 'libstdc++' in x or 'libgcc_s' in x
        ]
        for l in lines:
          os.chmod(target_path, 0o755)
          self.cmd(
            'Localize libstdc++ of %s' % self.target(),
            ['install_name_tool', '-change',
             l, '@rpath/%s' % (os.path.basename(l)), target_path],
            throw = True)
          os.chmod(target_path, 0o555)
          tgtdir = os.path.join(os.path.dirname(target_path), '..', 'lib')
          tgtfile = os.path.join(tgtdir, os.path.basename(l))
          if not os.path.exists(tgtdir):
            os.makedirs(tgtdir)
          if not os.path.exists(tgtfile):
            shutil.copy(l, tgtdir)
            output = subprocess.check_output(
              ['otool', '-L',  tgtfile])
            lines = output.decode('utf-8').strip().split('\n')
            lines = [
              x.replace('\t', '').split(' ')[0]
              for x in lines if 'libstdc++' in x or 'libgcc_s' in x
            ]
            for l in lines:
              os.chmod(tgtfile, 0o755)
              self.cmd(
                'Localize libstdc++ of %s' % tgtfile,
                ['install_name_tool', '-change',
                l, '@rpath/%s' % (os.path.basename(l)), tgtfile],
                throw = True)
              os.chmod(tgtfile, 0o555)
      return True

  prefix = drake.Path(prefix)
  if prefix.relative:
    prefix = drake.path_build(prefix, absolute = True)

  cxx_config = drake.cxx.Config(cxx_config)
  cxx_config.warnings.parentheses = False
  cxx_config.warnings.sign_compare = drake.cxx.Config.Warnings.Error;
  if production_build:
    cxx_config.enable_optimization()

  global git
  git = drake.git.Git()

  global elle
  elle = drake.include('elle',
                       production_build = production_build,
                       cxx_toolkit = cxx_toolkit,
                       cxx_config = cxx_config,
                       python3 = python,
                       fuse = fuse,
                       valgrind = valgrind,
                       prefix = False,
                       codesign = codesign)
  elle_lib = drake.copy(elle.elle.lib_dynamic, 'lib',
                        strip_prefix = True)
  aws_lib = drake.copy(elle.aws.library, 'lib',
                        strip_prefix = True)
  reactor_lib = drake.copy(elle.reactor.lib_dynamic, 'lib',
                        strip_prefix = True)
  dropbox_lib = drake.copy(elle.dropbox.lib_dynamic, 'lib',
                           strip_prefix = True)
  cryptography_lib = drake.copy(elle.cryptography.lib_dynamic, 'lib',
                                strip_prefix = True)
  protocol_lib = drake.copy(elle.protocol.lib_dynamic, 'lib',
                            strip_prefix = True)
  athena_lib = drake.copy(elle.athena.lib_dynamic, 'lib',
                          strip_prefix = True)
  cxx_toolkit = elle.cxx_toolkit
  cxx_config += elle.config
  cxx_config += elle.dropbox.config
  cxx_config += elle.athena.config
  cxx_config.add_local_include_path('src')
  cxx_config.define('_FILE_OFFSET_BITS=64')

  if cxx_toolkit.os in [drake.os.macos] and cxx_toolkit.kind == drake.cxx.GccToolkit.Kind.clang:
    cxx_config.use_local_libcxx = True

  global rule_build
  rule_build = drake.Rule('build')

  ## --------------- ##
  ## Infinit library ##
  ## --------------- ##

  cxx_config_infinit = drake.cxx.Config(cxx_config)
  cxx_config_infinit += elle.boost.config_system(link = False)
  cxx_config_infinit.library_add(
    drake.copy(elle.boost.system_dynamic, 'lib', True))
  cxx_config_infinit += elle.boost.config_filesystem(link = False)
  cxx_config_infinit.library_add(
    drake.copy(elle.boost.filesystem_dynamic, 'lib', True))
  cxx_config_infinit += elle.das.config

  class CxxVersionGenerator(VersionGenerator):
    def _variable(self, name, value):
      try:
        return '#define INFINIT_%s %s' % (name.upper(), int(value))
      except:
        return '#define INFINIT_%s "%s"' % (name.upper(), value)

  CxxVersionGenerator(drake.node('src/infinit/version.hh'), git)

  infinit_sources = drake.nodes(
    'src/infinit/RPC.hh',
    'src/infinit/RPC.hxx',
    'src/infinit/filesystem/filesystem.cc',
    'src/infinit/filesystem/filesystem.hh',
    'src/infinit/filesystem/AnyBlock.cc',
    'src/infinit/filesystem/AnyBlock.hh',
    'src/infinit/filesystem/Directory.cc',
    'src/infinit/filesystem/Directory.hh',
    'src/infinit/filesystem/File.cc',
    'src/infinit/filesystem/File.hh',
    'src/infinit/filesystem/FileHandle.cc',
    'src/infinit/filesystem/FileHandle.hh',
    'src/infinit/filesystem/FileData.hh',
    'src/infinit/filesystem/Node.cc',
    'src/infinit/filesystem/Node.hh',
    'src/infinit/filesystem/Symlink.cc',
    'src/infinit/filesystem/Symlink.hh',
    'src/infinit/filesystem/umbrella.hh',
    'src/infinit/filesystem/Unknown.cc',
    'src/infinit/filesystem/Unknown.hh',
    'src/infinit/model/Address.cc',
    'src/infinit/model/Address.hh',
    'src/infinit/model/MissingBlock.cc',
    'src/infinit/model/MissingBlock.hh',
    'src/infinit/model/Model.cc',
    'src/infinit/model/Model.hh',
    'src/infinit/model/Model.hxx',
    'src/infinit/model/User.hh',
    'src/infinit/model/blocks/ACLBlock.cc',
    'src/infinit/model/blocks/ACLBlock.hh',
    'src/infinit/model/blocks/Block.cc',
    'src/infinit/model/blocks/Block.hh',
    'src/infinit/model/blocks/ImmutableBlock.cc',
    'src/infinit/model/blocks/ImmutableBlock.hh',
    'src/infinit/model/blocks/MutableBlock.cc',
    'src/infinit/model/blocks/MutableBlock.hh',
    'src/infinit/model/blocks/ValidationResult.cc',
    'src/infinit/model/blocks/ValidationResult.hh',
    'src/infinit/model/blocks/fwd.hh',
    'src/infinit/model/doughnut/ACB.cc',
    'src/infinit/model/doughnut/ACB.hh',
    'src/infinit/model/doughnut/Async.cc',
    'src/infinit/model/doughnut/Async.hh',
    'src/infinit/model/doughnut/Cache.cc',
    'src/infinit/model/doughnut/Cache.hh',
    'src/infinit/model/doughnut/Conflict.cc',
    'src/infinit/model/doughnut/Conflict.hh',
    'src/infinit/model/doughnut/Consensus.cc',
    'src/infinit/model/doughnut/Consensus.hh',
    'src/infinit/model/doughnut/Doughnut.cc',
    'src/infinit/model/doughnut/Doughnut.hh',
    'src/infinit/model/doughnut/Local.cc',
    'src/infinit/model/doughnut/Local.hh',
    'src/infinit/model/doughnut/NB.cc',
    'src/infinit/model/doughnut/NB.hh',
    'src/infinit/model/doughnut/OKB.cc',
    'src/infinit/model/doughnut/OKB.hh',
    'src/infinit/model/doughnut/Passport.cc',
    'src/infinit/model/doughnut/Passport.hh',
    'src/infinit/model/doughnut/Peer.cc',
    'src/infinit/model/doughnut/Peer.hh',
    'src/infinit/model/doughnut/Remote.cc',
    'src/infinit/model/doughnut/Remote.hh',
    'src/infinit/model/doughnut/Remote.hxx',
    'src/infinit/model/doughnut/Replicator.cc',
    'src/infinit/model/doughnut/Replicator.hh',
    'src/infinit/model/doughnut/UB.cc',
    'src/infinit/model/doughnut/UB.hh',
    'src/infinit/model/doughnut/User.cc',
    'src/infinit/model/doughnut/User.hh',
    'src/infinit/model/doughnut/ValidationFailed.cc',
    'src/infinit/model/doughnut/ValidationFailed.hh',
    'src/infinit/model/doughnut/consensus/Paxos.cc',
    'src/infinit/model/doughnut/consensus/Paxos.hh',
    'src/infinit/model/faith/Faith.cc',
    'src/infinit/model/faith/Faith.hh',
    'src/infinit/model/paranoid/Paranoid.cc',
    'src/infinit/model/paranoid/Paranoid.hh',
    'src/infinit/overlay/Kalimero.cc',
    'src/infinit/overlay/Kalimero.hh',
    'src/infinit/overlay/Overlay.cc',
    'src/infinit/overlay/Overlay.hh',
    'src/infinit/overlay/Stonehenge.cc',
    'src/infinit/overlay/Stonehenge.hh',
    'src/infinit/overlay/kademlia/kademlia.cc',
    'src/infinit/overlay/kademlia/kademlia.hh',
    'src/infinit/overlay/kelips/Kelips.cc',
    'src/infinit/overlay/kelips/Kelips.hh',
    'src/infinit/serialization.cc',
    'src/infinit/serialization.hh',
    'src/infinit/smb/smb.cc',
    'src/infinit/storage/Adb.cc',
    'src/infinit/storage/Adb.hh',
    'src/infinit/storage/Async.cc',
    'src/infinit/storage/Async.hh',
    'src/infinit/storage/Cache.cc',
    'src/infinit/storage/Cache.hh',
    'src/infinit/storage/Collision.cc',
    'src/infinit/storage/Collision.hh',
    'src/infinit/storage/Crypt.cc',
    'src/infinit/storage/Crypt.hh',
    'src/infinit/storage/Dropbox.cc',
    'src/infinit/storage/Dropbox.hh',
    'src/infinit/storage/Filesystem.cc',
    'src/infinit/storage/Filesystem.hh',
    'src/infinit/storage/GoogleDrive.cc',
    'src/infinit/storage/GoogleDrive.hh',
    'src/infinit/storage/Key.hh',
    'src/infinit/storage/Latency.cc',
    'src/infinit/storage/Latency.hh',
    'src/infinit/storage/Memory.cc',
    'src/infinit/storage/Memory.hh',
    'src/infinit/storage/Mirror.cc',
    'src/infinit/storage/Mirror.hh',
    'src/infinit/storage/MissingKey.cc',
    'src/infinit/storage/MissingKey.hh',
    'src/infinit/storage/S3.cc',
    'src/infinit/storage/S3.hh',
    'src/infinit/storage/Storage.cc',
    'src/infinit/storage/Storage.hh',
    'src/infinit/storage/Strip.cc',
    'src/infinit/storage/Strip.hh',
    'src/infinit/storage/fwd.hh',
    'src/infinit/storage/sftp.cc',
    'src/infinit/storage/sftp.hh',
    'src/infinit/version.hh',
  )
  outguess_lib = drake.cxx.StaticLib('src/infinit/model/steg/outguess-0.2/outguess.a')
  jpeg_lib = drake.cxx.StaticLib('src/infinit/model/steg/outguess-0.2/jpeg-6b-steg/libjpeg.a')

  outguess_configure = drake.node('src/infinit/model/steg/outguess-0.2/configure')
  outguess_makefile = drake.node('src/infinit/model/steg/outguess-0.2/Makefile')

  infinit_lib = drake.cxx.DynLib(
    'lib/infinit',
    infinit_sources + [athena_lib,
                       elle_lib,
                       cryptography_lib,
                       aws_lib,
                       protocol_lib,
                       dropbox_lib],
    cxx_toolkit,
    cxx_config_infinit)
  rule_build << infinit_lib

  ## -------- ##
  ## Binaries ##
  ## -------- ##

  with drake.templating.Context(content = {
      'beyond_host': beyond_host,
  }):
    drake.node('bin/main.hh.tmpl')

  bin_cxx_config = drake.cxx.Config(cxx_config)
  bin_cxx_config += elle.das.config
  bin_cxx_config.add_local_include_path('bin')
  bin_cxx_config.lib_path_runtime('../lib')
  bin_cxx_config.library_add(
      drake.copy(elle.boost.program_options_dynamic, 'lib', True))
  bin_cxx_config.library_add(
      drake.copy(elle.boost.filesystem_dynamic, 'lib', True))
  bin_cxx_config.library_add(
      drake.copy(elle.boost.system_dynamic, 'lib', True))
  global installed_binaries
  to_install = [
    'infinit-credentials',
    'infinit-network',
    'infinit-storage',
    'infinit-user',
    'infinit-volume',
    'infinit-acl',
  ]

  binaries = [
    ('doughnode', []),
    ('generatekeys', []),
    ('infinit', []),
    ('s3fs', [aws_lib]),
    ('sshfs', []),
    ('infinit-smb', []),
  ]
  binaries += [
    (x, []) for x in to_install
  ]
  for bin_name, libs in binaries:
    source = drake.node('bin/%s.cc' % bin_name)
    bin = drake.cxx.Executable(
      'bin/%s' % bin_name, [
        source,
        infinit_lib,
        elle_lib,
        reactor_lib,
        cryptography_lib
      ] + libs,
      cxx_toolkit,
      bin_cxx_config)
    rule_build << bin
    if bin_name in to_install:
      installed_binaries.append(bin)
  steg = drake.cxx.Executable(
    'bin/steg',
    drake.nodes('src/infinit/model/steg/Steg.hh',
    'src/infinit/model/steg/Steg.cc',
    'bin/steg.cc'
    ) + [outguess_lib, jpeg_lib, infinit_lib],
    cxx_toolkit,
    bin_cxx_config,
  )

  ## ------- ##
  ## Install ##
  ## ------- ##
  global rule_install
  rule_install = drake.Rule('install')
  rule_install << drake.copy(installed_binaries, prefix, None,
                             builder = PatchAndInstall)
  # man = drake.nodes(
  #   'share/man/man1/infinit.1',
  #   'share/man/man5/infinit.5',
  # )
  # rule_install << drake.install(man, prefix)

  ## ----- ##
  ## Tests ##
  ## ----- ##

  rule_tests = drake.Rule('tests')
  rule_check = drake.Rule('check')

  cxx_config_tests = drake.cxx.Config(cxx_config)
  cxx_config_tests += elle.das.config
  cxx_config_tests.lib_path_runtime('../lib')
  cxx_config_tests += elle.boost.config_test(link = False)
  cxx_config_tests.library_add(
    drake.copy(elle.boost.test_dynamic, 'lib', True))
  cxx_config_tests += elle.boost.config_system(link = False)
  cxx_config_tests.library_add(
    drake.copy(elle.boost.system_dynamic, 'lib', True))
  cxx_config_tests += elle.boost.config_filesystem(link = False)
  cxx_config_tests.library_add(
    drake.copy(elle.boost.filesystem_dynamic, 'lib', True))

  for test_name in [
      'doughnut',
      'faith',
      'filesystem',
      'rpc',
      'storage',
  ]:
    test = drake.cxx.Executable(
      'tests/%s' % test_name,
      [
        drake.node('tests/%s.cc' % test_name),
        infinit_lib,
        elle_lib,
        cryptography_lib,
        reactor_lib,
        protocol_lib,
      ],
      cxx_toolkit,
      cxx_config_tests)

    rule_tests << test
    if valgrind_tests:
      runner = drake.valgrind.ValgrindRunner(
        exe = test, valgrind = valgrind)
    else:
      runner = drake.Runner(exe = test)
    runner.reporting = drake.Runner.Reporting.on_failure
    rule_check << runner.status
  for test_name in [
      'errors',
      'single-user-two-devices-shared-storage',
      'flow',
  ]:
    test = drake.node('tests/functional/%s' % test_name)
    test.dependencies_add(installed_binaries)
    runner = drake.Runner(exe = test,
                          env = { 'PYTHONPATH':
                                  drake.path_build('beyond/lib/python3.4') })
    rule_check << runner.status

  ## --- ##
  ## Web ##
  ## --- ##

  bottle = drake.node('bottle/bottle.py')
  sendwithus = drake.python.Package(
    'sendwithus',
    'sendwithus_python',
    drake.nodes(
      'sendwithus_python/sendwithus/__init__.py',
      'sendwithus_python/sendwithus/encoder.py',
      'sendwithus_python/sendwithus/version.py',
    ),
  )

  if elle.python3 is not None:
    beyond = drake.include(
      'beyond',
      python = elle.python3,
      cryptography_python_module = elle.cryptography.python_module,
      prefix = prefix,
      git = git,
      bottle = bottle,
      PatchAndInstall = PatchAndInstall,
    )
    rule_check << beyond.rule_check

  website = drake.include(
    'website',
    python = elle.python3,
    prefix = prefix,
    git = git,
    bottle = bottle,
    sendwithus = sendwithus,
    PatchAndInstall = PatchAndInstall,
  )
