import drake
import drake.cxx
import drake.debian
import drake.docker
import drake.git
import drake.license_file
import drake.python
import drake.redhat
import drake.valgrind

import os
import oset
import shutil

from itertools import chain

git = None

elle = None
installed_binaries = []

rule_build = None
rule_check = None
rule_install = None
rule_symbols = None
rule_tests = None

description_regex = '^.{0,2048}$'
email_regex = '^[^@]+@[^@]+\.[^@]+$'
name_regex = '^[-a-z0-9_][-a-z0-9._]{0,127}$'

beyond_delegate_user = 'hub'

license_file = None

with open(str(drake.path_source('elle/drake-utils.py')), 'r') as f:
  exec(f.read(), globals(), globals())

def configure(
    cxx_toolkit = None,
    cxx_config = drake.cxx.Config(),
    production_build = False,
    beyond_host = 'https://beyond.infinit.sh',
    boost = None,
    prefix = '/usr',
    valgrind = None,
    valgrind_tests = False,
    python = None,
    python3 = None, # Alias for python
    fuse = None,
    codesign = False,
    beyond: bool = True,
    website: bool = True,
    enable_crash_reporting: bool = True,
):

  if python3 is not None:
    python = python3

  global rule_build, rule_check, rule_install, rule_symbols, rule_tests
  rule_build = drake.Rule('build')
  rule_check = drake.Rule('check')
  rule_install = drake.Rule('install')
  rule_symbols = drake.Rule('symbols')
  rule_tests = drake.Rule('tests')
  rule_functional_tests = drake.Rule('functional/tests')
  rule_functional_check = drake.Rule('functional/check')

  class PatchAndInstall(drake.Install):
    def execute(self):
      if not super().execute():
        return False
      if cxx_toolkit.os == drake.os.macos:
        def set_lib_id(path):
          subprocess.check_output([
            'install_name_tool',
            '-id',
            '@rpath/%s' % os.path.basename(str(path)),
            str(path)])

        def get_deps_fix_rpaths(path):
          os.chmod(str(path), 0o755)
          if 'dylib' in str(path):
            set_lib_id(path)
          if cxx_toolkit.kind is drake.cxx.GccToolkit.Kind.gcc:
            otool_out = subprocess.check_output(['otool', '-L',  str(path)])
            otool_lines = otool_out.decode('utf-8').strip().split('\n')
            otool_lines = [
              x.replace('\t', '').split(' ')[0]
              for x in otool_lines[1:] if 'libstdc++' in x or 'libgcc_s' in x
            ]
            for l in otool_lines:
              drake.command([
                'install_name_tool', '-change',
                l, '@rpath/%s' % (os.path.basename(l)), str(path)
              ])
              dep_dir = os.path.normpath(
                os.path.join(os.path.dirname(str(path)), '..', 'lib'))
              dep_file = \
                os.path.normpath(os.path.join(dep_dir, os.path.basename(l)))
              if not os.path.exists(dep_dir):
                os.makedirs(dep_dir)
              if not os.path.exists(dep_file):
                import shutil
                shutil.copy(l, dep_dir)
                get_deps_fix_rpaths(drake.Path(dep_file))
                os.chmod(dep_file, 0o755)
                set_lib_id(dep_file)
                os.chmod(dep_file, 0o555)
            os.chmod(str(path), 0o555)

        path = self.target().path()
        get_deps_fix_rpaths(path)
      return True

  prefix = drake.Path(prefix)
  if prefix.relative:
    prefix = drake.path_build(prefix, absolute = True)

  cxx_config = drake.cxx.Config(cxx_config)
  cxx_config.warnings.parentheses = False
  cxx_config.warnings.sign_compare = drake.cxx.Config.Warnings.Error;
  if production_build:
    cxx_config.enable_optimization()
    cxx_config.define('INFINIT_PRODUCTION_BUILD')

  global git
  git = drake.git.Git()

  global elle
  elle = drake.include('elle',
                       production_build = production_build,
                       cxx_toolkit = cxx_toolkit,
                       cxx_config = cxx_config,
                       python3 = python,
                       fuse = fuse,
                       valgrind = valgrind,
                       prefix = False,
                       codesign = codesign)
  windows = elle.cxx_toolkit.os is drake.os.windows
  linux = elle.cxx_toolkit.os is drake.os.linux

  if not windows:
    dropbox_lib = drake.copy(elle.dropbox.lib_dynamic, 'lib',
                             strip_prefix = True)
    cryptography_lib = drake.copy(elle.cryptography.lib_dynamic, 'lib',
                                  strip_prefix = True)
    protocol_lib = drake.copy(elle.protocol.lib_dynamic, 'lib',
                              strip_prefix = True)
    reactor_lib = drake.copy(elle.reactor.lib_dynamic, 'lib',
                             strip_prefix = True)
    aws_lib = drake.copy(elle.aws.library, 'lib',
                         strip_prefix = True)
    elle_lib = drake.copy(elle.elle.lib_dynamic, 'lib',
                          strip_prefix = True)
    dokan_lib = None
    athena_lib = drake.copy(elle.athena.lib_dynamic, 'lib',
                            strip_prefix = True)
  else:
    dropbox_lib = elle.dropbox.lib_static
    cryptography_lib = elle.cryptography.lib_static
    protocol_lib = elle.protocol.lib_static
    reactor_lib = elle.reactor.lib_static
    aws_lib = elle.aws.library
    elle_lib = elle.elle.lib_static
    dokan_lib = elle.reactor.dokan_lib
    athena_lib = elle.athena.lib_static


  cxx_toolkit = elle.cxx_toolkit
  cxx_config += elle.config
  cxx_config += elle.dropbox.config
  cxx_config += elle.athena.config
  cxx_config.add_local_include_path('src')
  cxx_config.define('_FILE_OFFSET_BITS=64')

  if cxx_toolkit.os in [drake.os.macos] and cxx_toolkit.kind == drake.cxx.GccToolkit.Kind.clang:
    cxx_config.use_local_libcxx = True

  ## --------------- ##
  ## Infinit library ##
  ## --------------- ##

  cxx_config_infinit = drake.cxx.Config(cxx_config)

  cxx_config_infinit += elle.boost.config_system(link = False)
  if not windows:
    cxx_config_infinit.library_add(
      drake.copy(elle.boost.system_dynamic, 'lib', True))
  cxx_config_infinit += elle.boost.config_filesystem(link = False)
  if not windows:
    cxx_config_infinit.library_add(
      drake.copy(elle.boost.filesystem_dynamic, 'lib', True))
  cxx_config_infinit += elle.das.config

  class CxxVersionGenerator(VersionGenerator):
    def _variable(self, name, value):
      try:
        return '#define INFINIT_%s %s' % (name.upper(), int(value))
      except:
        return '#define INFINIT_%s "%s"' % (name.upper(), value)

  CxxVersionGenerator(drake.node('src/infinit/version.hh'),
                      git,
                      production_build = production_build)

  with drake.templating.Context(content = {
      'description_regex': description_regex,
      'name_regex': name_regex,
    }):
    drake.node('src/infinit/descriptor/TemplatedBaseDescriptor.hxx.tmpl')

  infinit_sources = drake.nodes(
    'src/infinit/RPC.cc',
    'src/infinit/RPC.hh',
    'src/infinit/RPC.hxx',
    'src/infinit/Version.hh',
    'src/infinit/serialization.cc',
    'src/infinit/serialization.hh',
    'src/infinit/smb/smb.cc',
    'src/infinit/utility.cc',
    'src/infinit/utility.hh',
    'src/infinit/version.hh',
  )
  infinit_sources += drake.include('src/infinit/credentials').sources
  infinit_sources += drake.include('src/infinit/descriptor').sources
  infinit_sources += drake.include('src/infinit/filesystem').sources
  infinit_sources += drake.include('src/infinit/model').sources
  infinit_sources += drake.include('src/infinit/overlay').sources
  infinit_sources += drake.include('src/infinit/storage').sources
  if not windows:
    infinit_sources += drake.nodes(
      'src/infinit/storage/sftp.cc',
      'src/infinit/storage/sftp.hh',
      )
  outguess_lib = drake.cxx.StaticLib('src/infinit/model/steg/outguess-0.2/outguess.a')
  jpeg_lib = drake.cxx.StaticLib('src/infinit/model/steg/outguess-0.2/jpeg-6b-steg/libjpeg.a')

  outguess_configure = drake.node('src/infinit/model/steg/outguess-0.2/configure')
  outguess_makefile = drake.node('src/infinit/model/steg/outguess-0.2/Makefile')

  if windows:
    cxx_config_infinit.lib('shlwapi')
    cxx_config_infinit.lib('ws2_32')
    cxx_config_infinit.lib('gdi32')
    cxx_config_infinit.lib('mswsock')
    cxx_config_infinit.lib('dbghelp')
    cxx_config_infinit.lib('iphlpapi')
    cxx_config_infinit.lib('crypt32')
    cxx_config_infinit.library_add(elle.boost.regex_static)
    libtype = drake.cxx.DynLib
    extra_libs = [drake.copy(dokan_lib, 'bin', strip_prefix = True)]
    cxx_config_infinit.use_whole_archive()
  else:
    cxx_config_infinit.library_add(
      drake.copy(elle.boost.regex_dynamic, 'lib', True))
    extra_libs = []
    libtype = drake.cxx.DynLib
  infinit_lib = libtype(
    (windows and 'bin' or 'lib') + '/infinit',
    infinit_sources + [athena_lib,
                       cryptography_lib,
                       aws_lib,
                       protocol_lib,
                       dropbox_lib,
                       reactor_lib,
                       elle_lib
                       ] + extra_libs,
    cxx_toolkit,
    cxx_config_infinit,
    strip = windows)
  rule_build << infinit_lib

  if not windows and enable_crash_reporting:
    crash_reporting = drake.include('crash_reporting',
                                    cxx_toolkit = cxx_toolkit,
                                    cxx_config = cxx_config)
    crash_reporter_lib = drake.copy(crash_reporting.library, 'lib',
                                    strip_prefix = True)

  ## -------- ##
  ## Binaries ##
  ## -------- ##

  def cpp_str_escape(string):
    from json import dumps
    return dumps(string).strip('"')

  with drake.templating.Context(content = {
      'beyond_delegate_user': beyond_delegate_user,
      'beyond_host': beyond_host,
      'email_regex': cpp_str_escape(email_regex),
      'name_regex': name_regex,
  }):
    drake.node('bin/main.hh.tmpl')
    drake.node('bin/email.hh.tmpl')
    drake.node('bin/infinit-drive.cc.tmpl')

  drake.nodes(
    'bin/endpoint_file.hh',
    'bin/password.hh',
  )

  xattr_sources = drake.nodes(
    'bin/xattrs.cc',
    'bin/xattrs.hh',
    'bin/xattrs.hxx',
  )

  bin_cxx_config = drake.cxx.Config(cxx_config)
  bin_cxx_config += elle.das.config
  bin_cxx_config.add_local_include_path('bin')
  bin_cxx_config.add_local_include_path('crash_reporting/src')
  bin_cxx_config.lib_path_runtime('../lib')
  if not windows:
    bin_cxx_config.library_add(
      drake.copy(elle.boost.program_options_dynamic, 'lib', True))
    bin_cxx_config.library_add(
      drake.copy(elle.boost.filesystem_dynamic, 'lib', True))
    bin_cxx_config.library_add(
      drake.copy(elle.boost.regex_dynamic, 'lib', True))
    bin_cxx_config.library_add(
      drake.copy(elle.boost.system_dynamic, 'lib', True))
    if cxx_toolkit.os is drake.os.macos:
      bin_cxx_config.framework_add('CoreServices')
      bin_cxx_config.ldflag('-headerpad_max_install_names')
  else:
    bin_cxx_config.lib('shlwapi')
    bin_cxx_config.lib('ws2_32')
    bin_cxx_config.lib('gdi32')
    bin_cxx_config.lib('mswsock')
    bin_cxx_config.lib('dbghelp')
    bin_cxx_config.lib('iphlpapi')
    bin_cxx_config.lib('crypt32')
    bin_cxx_config.library_add(
      drake.copy(dokan_lib, 'bin', True))
    bin_cxx_config.library_add(elle.boost.program_options_static)
    bin_cxx_config.define('ELLE_SERIALIZATION_USE_DLL')
    #bin_cxx_config.use_whole_archive()
  # Ship libstdc++
  additional_libs = []
  if linux:
    searched_for = {'libstdc++', 'libgcc_s'}
    need_64 = cxx_toolkit.architecture == drake.architecture.x86_64
    try:
      output = subprocess.check_output(['ldconfig', '-p'])
    except Exception:
      output = ''.join([ (need_64 and 'x86-64 ' or '') + '/usr/lib/'+x+'.so\n' for x in searched_for]).encode('utf-8')
    path = None
    for line in output.decode('utf-8').split('\n'):
      for searched in searched_for:
        if searched in line:
          if need_64 != ('x86-64' in line):
            continue
          path = drake.Path(line.split(' ')[-1])
          additional_libs.append(
            drake.copy(drake.cxx.DynLib(path), 'lib', strip_prefix = True))
          searched_for.remove(searched)
          break
      if not searched_for:
        break
    if searched_for:
      raise Exception('Unable to find %s with ldconfig -p' %
                      ', '.join(searched_for))

  # Build
  # ('binary name', [additional sources], [additional libraries], ship)
  binaries_config = [
    ('doughnode', [], [], False),
    ('generatekeys', [], [], False),
    ('infinit', [], [], False),
    ('infinit-acl', [xattr_sources], [], True),
    ('infinit-block', [], [], True),
    ('infinit-credentials', [], [], True),
    ('infinit-device', [], [], True),
    ('infinit-doctor', [], [], True),
    ('infinit-drive', [], [], True),
    ('infinit-journal', [], [], True),
    ('infinit-network', [xattr_sources], [], True),
    ('infinit-passport', [], [], True),
    ('infinit-smb', [], [], False),
    ('infinit-storage', [], (not windows) and [aws_lib] or [], True),
    ('infinit-user', [], [], True),
    ('infinit-volume', [], [], True),
    ('infinit-webdav', [], [], False),
    ('infinit-fsck', [], [], False),
    ('reactor-example', [], [], False),
    # ('s3fs', [], [aws_lib], False),
  ]
  if elle.elle.ldap:
    binaries_config.append(('infinit-ldap', [xattr_sources], [], True))
  if (cxx_toolkit.os is drake.os.linux) or \
      (production_build is False and cxx_toolkit.os is drake.os.macos):
    binaries_config.append(('infinit-daemon', [], [], True))
  if not windows:
    binaries_config.append(('sshfs', [], [], False))
    if enable_crash_reporting:
      additional_libs.append(crash_reporter_lib)
    additional_libs += [elle_lib, reactor_lib, cryptography_lib]
  else:
    pass
  binaries = []
  global installed_binaries
  installed_binaries = []
  installed_symbols = []
  debian_debug_dir = 'debian-debug'
  debian_syms_dir = \
    drake.path_build('%s/opt/infinit/lib/infinit/debug' % debian_debug_dir)
  installed_libraries = []
  bin_version = drake.node('bin/version.cc')
  bin_sources = drake.nodes('bin/main.cc', 'bin/main.hh')
  for name, other_sources, libs, install in binaries_config:
    source = drake.node('bin/%s.cc' % name)
    additional_sources = []
    for s in other_sources:
      additional_sources.extend(s)
    bin = drake.cxx.Executable(
      'bin/%s' % name, [
        source,
        bin_version,
        infinit_lib,
      ] + bin_sources + additional_sources + libs + additional_libs,
      cxx_toolkit,
      bin_cxx_config,
      strip = windows)
    rule_build << bin
    binaries.append(bin)
    if install:
      installed_binaries.append(bin)
      if not windows and enable_crash_reporting:
        bin_sym = drake.node('bin/symbols/%s.sym' % name)
        crash_reporting.SymbolsGenerator(crash_reporting.dump_syms_exe,
                                         bin,
                                         bin_sym)
        installed_symbols.append(bin_sym)
      def add_libraries(binary):
        installed_libraries.extend(binary.dynamic_libraries)
        for lib in binary.dynamic_libraries:
          add_libraries(lib)
      add_libraries(bin)
  if not windows and enable_crash_reporting:
    for lib in set(installed_libraries):
      lib_sym = drake.node('lib/symbols/%s.sym' % lib.path().basename())
      crash_reporting.SymbolsGenerator(crash_reporting.dump_syms_exe,
                                       lib,
                                       lib_sym)
      installed_symbols.append(lib_sym)

    if prefix:
      symbols_dir = '%s/%s' % (prefix, git.version())
      for s in installed_symbols:
        rule_symbols << drake.copy(s, symbols_dir, strip_prefix = True)

  if elle.reactor.fnetusermount_binaries is not None:
    for f in elle.reactor.fnetusermount_binaries:
      t = drake.copy(f, '.', strip_prefix = 'elle/reactor')
      installed_binaries.append(t)

  ## ----- ##
  ## Share ##
  ## ----- ##

  demo_home = drake.nodes(
    'demo-home/linked_networks/demo/infinit/demo',
    'demo-home/networks/infinit/demo',
    'demo-home/passports/infinit/demo/demo',
    'demo-home/users/demo',
    'demo-home/volumes/infinit/demo',
  )

  ## -------- ##
  ## Licenses ##
  ## -------- ##
  global license_file
  license_file = drake.node('OSS-licenses')
  drake.license_file.Packager('licenses', license_file)

  ## ------- ##
  ## Install ##
  ## ------- ##

  def install_nodes(where, demo = True):
    where = drake.Path(where)
    yield from drake.copy(installed_binaries, where, None,
                          builder = PatchAndInstall)
    if demo:
      yield from drake.copy(
        demo_home, where / 'share/infinit/filesystem/test/home', 'demo-home')
    yield from drake.copy(
      [license_file], where / 'share/infinit/filesystem/licenses')

  rule_install << install_nodes(prefix)

  # man = drake.nodes(
  #   'share/man/man1/infinit.1',
  #   'share/man/man5/infinit.5',
  # )
  # rule_install << drake.install(man, prefix)

  ## ------ ##
  ## Debian ##
  ## ------ ##

  debian_nodes = install_nodes('debian/opt/infinit')
  git = drake.git.Git()
  if cxx_toolkit.os is drake.os.linux:
    from platform import linux_distribution
    platform = linux_distribution()[0].lower().replace(' ', '-')
  elif cxx_toolkit.os is drake.os.macos:
    platform = 'macosx'
  else:
    platform = 'unknown'
  def make_executable(target):
    os.chmod(str(target), 0o755)
    return True
  debian_nodes = chain(
    debian_nodes,
    drake.copy(drake.nodes('debian-packaging/release/postinst'),
                           'debian/DEBIAN',
                           post_process = make_executable,
                           strip_prefix = True),
  )
  rule_debian = drake.Rule('debian')
  if cxx_toolkit.os is drake.os.linux:
    rule_debian << drake.debian.Packager(
      'infinit_%s_amd64.deb' % git.description(),
      {
        'Package': 'infinit',
        'Maintainer': 'Quentin Hocquet <mefyl@infinit.io>',
        'Version': git.description(),
        'Homepage': 'https://www.infinit.sh',
        'Architecture': 'amd64',
        'Description': 'Infinit distributed filesystem.',
        'Section': 'utils',
        'Priority': 'optional',
      },
      debian_nodes,
      'debian').package

  if not windows and enable_crash_reporting:
    rule_debian_debug = drake.Rule('debian-debug')
    name = 'infinit-debug-symbols-%s-%s_0_amd64.deb' % (platform, git.description())
    debian_debug_package = crash_reporting.SymbolsPackager(
      name,
      {
        'Package': 'infinit-debug-symbols-%s-%s' % \
          (platform, git.description()),
        'Maintainer': 'Quentin Hocquet <mefyl@infinit.io>',
        'Version': '0',
        'Homepage': 'https://www.infinit.sh',
        'Architecture': 'amd64',
        'Description':
          'Infinit distributed filesystem debug symbols.',
        'Section': 'utils',
        'Priority': 'optional',
      },
      installed_symbols,
      debian_debug_dir).package
    rule_debian << debian_debug_package
    rule_debian_debug << debian_debug_package

  ## ------- ##
  ## Red Hat ##
  ## ------- ##

  redhat_version = git.description().replace('-', '_')
  redhat_rule = drake.Rule('redhat')
  redhat_build_root = 'redhat/BUILDROOT'
  redhat_nodes = list(install_nodes('%s/opt/infinit' % redhat_build_root))
  def installed_files(nodes):
    def clean_path(path):
      return str(path).replace(
        '%s/' % drake.path_build(), '').replace(redhat_build_root, '')
    res = set()
    for node in nodes:
      res.add(clean_path(node))
      if isinstance(node, drake.cxx.Executable):
        for dep in node.dependencies_recursive:
          res.add(clean_path(dep))
    return sorted(list(res))

  with drake.templating.Context(content = {
      'changelog': '',
      'files': '\n'.join(installed_files(redhat_nodes)),
      'glibc_version': '2.12',
      'version': redhat_version,
  }):
    drake.node('redhat-packaging/package/infinit.spec.tmpl')

  redhat_nodes = chain(
    redhat_nodes,
    drake.copy(drake.nodes('redhat-packaging/package/infinit.spec'),
               'redhat/SPECS', strip_prefix = True),
  )

  redhat_package = drake.redhat.Packager('infinit',
                                         redhat_version,
                                         'el6', 'x86_64',
                                         drake.path_build('redhat'),
                                         redhat_nodes).package
  redhat_rule << redhat_package

  redhat_repo_version = '0.1'
  with drake.templating.Context(content = {
      'base_url': 'http://127.0.0.1',
      'gpg_key': 'http://127.0.0.1/gpg.pub',
      'files': '/etc/yum.repo.d/infinit.repo',
      'version': redhat_repo_version,
  }):
    drake.node('redhat-packaging/repository/infinit-release.spec.tmpl')
    drake.node('redhat-packaging/repository/infinit.repo.tmpl')

  redhat_repo_nodes = chain(
    drake.copy(drake.nodes('redhat-packaging/repository/infinit-release.spec'),
               'redhat-repo/SPECS', strip_prefix = True),
    drake.copy(drake.nodes('redhat-packaging/repository/infinit.repo'),
               'redhat-repo/BUILDROOT/etc/yum.repo.d', strip_prefix = True),
  )

  redhat_repo_package = drake.redhat.Packager('infinit-release',
                                              redhat_repo_version,
                                              'el6', 'x86_64',
                                              drake.path_build('redhat-repo'),
                                              redhat_repo_nodes).package
  redhat_rule << redhat_repo_package


  ## ------ ##
  ## Docker ##
  ## ------ ##

  # infinit image
  docker_path = drake.Path('docker')
  docker_image = drake.docker.DockerImage(
    'docker', 'infinit', git.description())
  docker_file = drake.docker.DockerFile(
    docker_path / 'Dockerfile',
    image = 'ubuntu',
    maintainer = 'Infinit <contact@infinit.sh>',
    labels = {
      'version': git.description(),
    })
  docker_file.run('apt-get update && apt-get install -y python3')
  docker_file.add(install_nodes(docker_path, demo = False), '/usr')
  docker_file.add(
    drake.copy(drake.node('share/infinit/docker/infinit-static.sh'),
               docker_path / 'bin', strip_prefix = True),
    '/usr')
  docker_file.add(
    drake.copy(drake.node('share/infinit/docker/infinit-service-runner.py'),
               docker_path / 'bin', strip_prefix = True),
    '/usr')
  docker_file.add(
    drake.copy(drake.node('share/infinit/docker/infinit-context.sh'),
               docker_path / 'bin', strip_prefix = True),
    '/usr')
  docker_file.run('ln -s /usr/bin/fnetusermount-client /bin/fusermount')
  drake.docker.DockerBuilder(docker_image, docker_file)


  # infinit alpine image
  docker_path = drake.Path('docker-alpine')
  docker_image = drake.docker.DockerImage(
    'docker-alpine', 'infinit-alpine', git.description())
  docker_file = drake.docker.DockerFile(
    docker_path / 'Dockerfile',
    image = 'alpine',
    maintainer = 'Infinit <contact@infinit.sh>',
    labels = {
      'version': git.description(),
    })
  docker_file.add(install_nodes(docker_path, demo = False), '/usr')
  docker_file.add(
    drake.copy(drake.node('share/infinit/docker/infinit-static.sh'),
               docker_path / 'bin', strip_prefix = True),
    '/usr')
  docker_file.add(
    drake.copy(drake.node('share/infinit/docker/infinit-service-runner.py'),
               docker_path / 'bin', strip_prefix = True),
    '/usr')
  docker_file.add(
    drake.copy(drake.node('share/infinit/docker/infinit-context.sh'),
               docker_path / 'bin', strip_prefix = True),
    '/usr')
  docker_file.run('ln -s /usr/bin/fnetusermount-client /bin/fusermount')
  docker_file.run("ln -s 'libstdc++.so' '/usr/lib/libstdc++.so.6'")
  docker_file.run("ln -s 'libgcc_s.so' '/usr/lib/libgcc_s.so.1'")
  drake.docker.DockerBuilder(docker_image, docker_file)



  #fnetusermount-server image
  if elle.reactor.fnetusermount_binaries is not None:
    docker_path = drake.Path('docker-fnetusermount')
    docker_image = drake.docker.DockerImage(
      'docker-fnetusermount', 'infinit-fnetusermount', git.description())
    docker_file = drake.docker.DockerFile(
      docker_path / 'Dockerfile',
      image = 'ubuntu',
      maintainer = 'Infinit <contact@infinit.sh>',
      labels = {
        'version': git.description(),
      })
    docker_file.add(
      drake.copy(
        elle.reactor.fnetusermount_binaries, docker_path / 'bin',
        strip_prefix = True),
      '/usr')
    docker_file.add(
      drake.copy(additional_libs, docker_path / 'lib',
        strip_prefix = True),
      '/usr')
    docker_file.run('apt-get update')
    docker_file.run('apt-get install -y fuse') # for fusermount
    drake.docker.DockerBuilder(docker_image, docker_file)

  #deployment script image
  docker_path = drake.Path('docker-deploy')
  docker_image = drake.docker.DockerImage(
    'docker-deploy', 'infinit-deploy', git.description())
  docker_file = drake.docker.DockerFile(
    docker_path / 'Dockerfile',
    image = 'alpine:3.3',
    maintainer = 'Infinit <contact@infinit.sh>',
    labels = {
      'version': git.description(),
    })
  docker_file.add(
    drake.copy(drake.node('share/infinit/docker/infinit-deploy/entry.sh'),
               docker_path / 'bin', strip_prefix = True),
    '/usr')
  docker_file.run('apk add --update bash ca-certificates jq groff less curl python py-pip && pip install awscli && apk --purge -v del py-pip && rm -rf /var/cache/apk/*')
  docker_file.run(' mkdir /lib64 && ln -s /lib/libc.musl-x86_64.so.1 /lib64/ld-linux-x86-64.so.2')
  drake.docker.DockerBuilder(docker_image, docker_file)

  ## ------ ##
  ## Beyond ##
  ## ------ ##

  if elle.python3:
    bottle = drake.node('bottle/bottle.py')
    sendwithus = drake.python.Package(
      'sendwithus',
      'sendwithus_python',
      drake.nodes(
        'sendwithus_python/sendwithus/__init__.py',
        'sendwithus_python/sendwithus/encoder.py',
        'sendwithus_python/sendwithus/exceptions.py',
        'sendwithus_python/sendwithus/version.py',
      ),
    )
    if beyond:
      beyond = drake.include(
        'beyond',
        production_build = production_build,
        python = elle.python3,
        cryptography_python_module = elle.cryptography.python_module,
        sendwithus = sendwithus,
        prefix = prefix,
        git = git,
        bottle = bottle,
        PatchAndInstall = PatchAndInstall,
        description_regex = description_regex,
        email_regex = email_regex,
        name_regex = name_regex,
        backend = {
          'binaries': installed_binaries,
          'debian': rule_debian
        },
      )
      if not windows and enable_crash_reporting:
        crash_test_libs = drake.copy([
            crash_reporter_lib,
            cryptography_lib,
            elle_lib,
            reactor_lib,
          ] + additional_libs,
          'tests/functional/lib', True)
        crash_test_libs += drake.copy([
            elle.boost.program_options_dynamic,
            elle.boost.filesystem_dynamic,
            elle.boost.regex_dynamic,
          ], 'tests/functional/lib', True)
        crash_test_bin = drake.cxx.Executable(
          'tests/functional/bin/crasher', [
            drake.node('tests/functional/bin/crasher.cc')
          ] + crash_test_libs,
          cxx_toolkit,
          bin_cxx_config)
      def functional_test(name, env = {}, binaries = []):
        t = {
          'name': name
        }
        if env:
          t['env'] = env
        if binaries:
          t['dependencies'] = binaries
          t['paths'] = [str(x.path(True).dirname()) for x in binaries]
        return t
      utils = drake.node('tests/functional/utils.py')
      tests = list(
        map(lambda x: functional_test(x),
            [
              'cli-backward-compatibility',
              'device_cli',
              'drive_cli',
              'errors',
              #FIXME: 'flow',
              'main_cli',
              'network_cli',
              'passport-restrictions',
              'passport-sign-delegate',
              'passport_cli',
              # 'rebalancing',
              'single-user-two-devices-shared-storage',
              'storage_cli',
              'user_cli',
              'volume_cli',
            ]))
      if not windows and enable_crash_reporting:
        tests.append(functional_test('crash-reporter'))
      if linux:
        pjdfstest = drake.include(
          'pjdfstest',
          cxx_toolkit = cxx_toolkit,
          cxx_config = cxx_config)
        tests.append(functional_test(
          'pjdfstest',
          {
            'PJDFSTESTS': str(pjdfstest.tests_folder),
            'PATH': '%s:%s' % (
              drake.path_build('pjdfstest', absolute = True),
              os.environ['PATH']),
          },
          [pjdfstest.pjdfstest]
        ))
      for t in tests:
        test = drake.node('tests/functional/%s' % t['name'])
        rule_functional_tests << test
        if not windows and enable_crash_reporting:
          test.dependencies_add([crash_test_bin])
        test.dependencies_add(installed_binaries)
        test.dependencies_add(beyond.package.nodes)
        test.dependencies_add(t.get('dependencies', []))
        test.dependency_add(drake.node('tests/functional/utils.py'))
        binaries_path = str(drake.path_build(installed_binaries[0].path(True).dirname(),
                                             absolute = True))
        extra_path = [binaries_path]
        extra_path += t.get('paths', [])
        if not windows and enable_crash_reporting:
          extra_path.append(str(drake.path_build(crash_test_bin.path(True).dirname(),
                                                 absolute = True)))
        extra_path.append(os.environ.get('PATH', ''))
        env = {
          'PYTHONPATH':
            str(drake.path_build('beyond/lib/python%s' % elle.python3.version)),
          'SOURCE_DIR': drake.path_source(),
          'BUILD_DIR': drake.path_build(),
          'OS': 'windows' if windows else 'unix',
          'INFINIT_BINARIES': str(binaries_path)
        }
        env.update(t.get('env', {}))
        if cxx_toolkit.os == drake.os.windows:
          env['EXE_EXT'] = '.exe'
        runner = drake.Runner(
          exe = test,
          env = env,
          sources = [utils],
        )
        rule_functional_check << runner.status
        runner.reporting = drake.Runner.Reporting.on_failure
      rule_tests << rule_functional_tests
      rule_check << rule_functional_check
    if website:
      website = drake.include(
        'website',
        python = elle.python3,
        prefix = prefix,
        git = git,
        bottle = bottle,
        sendwithus = sendwithus,
        PatchAndInstall = PatchAndInstall,
      )

  ## ----- ##
  ## Tests ##
  ## ----- ##

  cxx_config_tests = drake.cxx.Config(cxx_config)
  cxx_config_tests += elle.das.config
  cxx_config_tests.lib_path_runtime('../lib')
  cxx_config_tests.lib_path_runtime('../../lib') # For consensus/async test.
  cxx_config_tests += elle.boost.config_test(link = False)
  cxx_config_tests += elle.boost.config_timer(link = False)
  cxx_config_tests.add_local_include_path('bin')
  if not windows:
    cxx_config_tests.library_add(
      drake.copy(elle.boost.test_dynamic, 'lib', True))
    cxx_config_tests.library_add(
      drake.copy(elle.boost.timer_dynamic, 'lib', True))
    cxx_config_tests += elle.boost.config_system(link = False)
    cxx_config_tests.library_add(
      drake.copy(elle.boost.system_dynamic, 'lib', True))
    cxx_config_tests += elle.boost.config_filesystem(link = False)
    cxx_config_tests.library_add(
      drake.copy(elle.boost.filesystem_dynamic, 'lib', True))
    cxx_config_tests += elle.boost.config_program_options(
      link = False)
    cxx_config_tests.library_add(
      drake.copy(elle.boost.program_options_dynamic, 'lib', True))
    cxx_config_tests.library_add(
      drake.copy(elle.boost.regex_dynamic, 'lib', True))
    cxx_config_tests_no_boost_test = drake.cxx.Config(cxx_config_tests)
    infinit_lib_tests = infinit_lib
    infinit_lib_tests_consensus = infinit_lib
  else:
    cxx_config_tests.lib('shlwapi')
    cxx_config_tests.lib('ws2_32')
    cxx_config_tests.lib('gdi32')
    cxx_config_tests.lib('mswsock')
    cxx_config_tests.lib('dbghelp')
    cxx_config_tests.lib('iphlpapi')
    cxx_config_tests.lib('crypt32')
    cxx_config_tests.library_add(elle.boost.filesystem_static)
    cxx_config_tests.library_add(elle.boost.program_options_static)
    cxx_config_tests.library_add(elle.boost.system_static)
    cxx_config_tests.library_add(elle.boost.regex_static)
    cxx_config_tests.use_whole_archive()
    cxx_config_tests.define('ELLE_SERIALIZATION_USE_DLL')
    cxx_config_tests.define('ELLE_TEST_NO_MEMFRY') # does not cross DLL boundaries

    cxx_config_tests_no_boost_test = drake.cxx.Config(cxx_config_tests)
    cxx_config_tests.library_add(elle.boost.test_static)
    cxx_config_tests.library_add(elle.boost.timer_static)
    infinit_lib_tests = drake.copy(infinit_lib, 'tests',
                                   strip_prefix = True)
    infinit_lib_tests_consensus = drake.copy(infinit_lib, 'tests/consensus',
                                             strip_prefix = True)
    dokan_lib_tests = drake.copy(dokan_lib, 'tests', strip_prefix = True)
    dokan_lib_tests_consensus = drake.copy(dokan_lib, 'tests/consensus',
                                             strip_prefix = True)
  tests_names = [
    ('async-conflict', []),
    ('backward-compatibility', []),
    ('bandwidth', []),
    ('consensus/async', []),
    ('consensus/cache', []),
    ('consensus/paxos', []),
    ('doughnut', []),
    ('faith', []),
    ('filesystem', binaries),
    ('kelips', []),
    ('overlay', []),
    ('rpc', []),
    ('storage', [aws_lib]),
  ]
  if not windows:
    tests_extra_libs = [elle_lib, cryptography_lib, reactor_lib, protocol_lib]
  else:
    tests_extra_libs = []
  for test_name, dependencies in tests_names:
    ifnt_lib = test_name == 'consensus/async' and infinit_lib_tests_consensus or infinit_lib_tests
    if windows:
      if test_name == 'consensus/async':
        tests_extra_libs += [dokan_lib_tests_consensus]
      else:
        tests_extra_libs += [dokan_lib_tests]
    if test_name == 'kelips':
      tests_extra_libs += [drake.node('bin/main.cc'), drake.node('bin/version.cc')]
      if not windows:
        tests_extra_libs.append(crash_reporter_lib)
    test = drake.cxx.Executable(
      'tests/%s' % test_name,
      [
        drake.node('tests/%s.cc' % test_name),
        ifnt_lib
      ] + tests_extra_libs,
      cxx_toolkit,
      test_name == 'backward-compatibility' and cxx_config_tests_no_boost_test or cxx_config_tests)
    test.dependencies_add(dependencies)
    rule_tests << test
    env = {
      'SOURCE_DIR': drake.path_source(),
      'BUILD_DIR': drake.path_build(),
    }
    #  _____ _____  ____  __ _____
    # |  ___|_ _\ \/ /  \/  | ____|
    # | |_   | | \  /| |\/| |  _|
    # |  _|  | | /  \| |  | | |___
    # |_|   |___/_/\_\_|  |_|_____|
    #
    # Really, really do run these tests on valgrind !!!
    if valgrind_tests and test_name not in ['filesystem', 'kelips']:
      runner = drake.valgrind.ValgrindRunner(
        exe = test,
        valgrind = elle.valgrind,
        env = env)
    else:
      runner = drake.Runner(exe = test, env = env)
    runner.reporting = drake.Runner.Reporting.on_failure
    rule_check << runner.status
