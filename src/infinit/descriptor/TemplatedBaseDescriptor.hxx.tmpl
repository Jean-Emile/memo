#include <boost/regex.hpp>

#include <elle/serialization/Serializer.hh>

namespace infinit
{
  namespace descriptor
  {
    template <typename T>
    void
    TemplatedBaseDescriptor<T>::check_name(std::string const& name)
    {
      std::string test_name;
      auto slash_pos = name.find_first_of("/");
      if (!T::permit_name_slash() && slash_pos != std::string::npos)
        throw DescriptorNameError(name);
      if (slash_pos == std::string::npos)
        test_name = name;
      else
        test_name = name.substr(slash_pos + 1);
      static const boost::regex allowed("${name_regex}");
      boost::smatch str_matches;
      if (!boost::regex_match(test_name, str_matches, allowed))
        throw DescriptorNameError(name);
    }

    template <typename T>
    void
    TemplatedBaseDescriptor<T>::check_description(std::string const& desc)
    {
      if (desc.size() > 1024)
        throw DescriptorError("description must be less than 1024 characters");
    }

    /*-------------.
    | Construction |
    `-------------*/

    template <typename T>
    TemplatedBaseDescriptor<T>::TemplatedBaseDescriptor(
        std::string name,
        boost::optional<std::string> description)
      : BaseDescriptor(std::move(name), std::move(description))
    {
      check_name(this->name);
    }

    template <typename T>
    TemplatedBaseDescriptor<T>::TemplatedBaseDescriptor(
        TemplatedBaseDescriptor const& descriptor)
      : BaseDescriptor(descriptor)
    {
      check_name(this->name);
    }

    /*--------------.
    | Serialization |
    `--------------*/

    template <typename T>
    TemplatedBaseDescriptor<T>::TemplatedBaseDescriptor(
        elle::serialization::SerializerIn& s)
      : BaseDescriptor(s)
    {
      check_name(this->name);
    }
  }
}
