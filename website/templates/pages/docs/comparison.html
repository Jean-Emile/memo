<%inherit file="/base.html"/>

<%block name="content">

  <%include file='menu.html'/>

  <section class="doc ${competitor_name}">
    <img class="competitor big" src="${url('images/logos/' + competitor_name + '.png')}" alt="${competitor['name']} logo">
    <h1>${competitor['name']}</h1>
    <p>${competitor['description']}</p>

    % if competitor_name != 'infinit':
      <div class="filters">
        <label for="switcher">Show comparison with Infinit</label>
        <input type="checkbox" class="js-switch" ${'checked' if show_comparison else ''} />
      </div>
    % endif

    <div class="properties ${'compared' if show_comparison else ''}">
    <%
      properties = [None]*9

      for property, value in competitor['properties'].items():
        if property == 'architecture':
          properties[0] = ['architecture', value]
        elif property == 'interface':
          properties[1] = ['interface', value]
        elif property == 'model':
          properties[2] = ['model', value]
        elif property == 'environment':
          properties[3] = ['environment', value]
        elif property == 'redundancy':
          properties[4] = ['redundancy', value]
        elif property == 'fault_tolerance':
          properties[5] = ['fault_tolerance', value]
        elif property == 'security':
          properties[6] = ['security', value]
        elif property == 'scalability':
          properties[7] = ['scalability', value]
        elif property == 'interoperability':
          properties[8] = ['interoperability', value]
    %>

    % for property, value in properties:
      <%
        value_infinit = infinit['properties'][property]
        if property == "interoperability" and "Applications" in value and "Applications" in value_infinit:
          is_similar = True
        elif value == infinit['properties'][property]:
          is_similar = True
        else:
          is_similar = False
      %>

      <div class="property ${'same' if is_similar else 'different'}">
        <img class="" src="${url('images/icons/' + property + '.png')}" alt="${property}">
        <h2>${property.replace('_', ' ').title()}</h2>
        <p class="note">
        % if property == 'architecture':
          % if value == 'Object':
            Object-based storage architecture manage data as objects and are used mostly to store application-specific data. <a class="open-popup" href="#object-file">Read more.</a>
          % else:
            File-based solutions provide humans with a way to store and collaborate around files organized through a hierarchy of folders. <a class="open-popup" href="#object-file">Read more.</a>
          % endif

        % elif property == 'scalability':
          % if value == 'Heterogeneous':
            Heterogeneous systems can scale by integrating additional storage capacity from resources of different nature being a cloud storage provider, a local disk, a SAN etc. <a class="open-popup" href="#scalability">Read more.</a>
          % elif value == 'Homogeneous':
            Homogeneous systems can scale up and out but are limited to resources that are under the control of the infrastructure's administrator: local disk, NAS etc. <a class="open-popup" href="#scalability">Read more.</a>
          % else:
            Some systems do not allow for the overall storage capacity to evolve over time. <a class="open-popup" href="#scalability">Read more.</a>
          % endif

        % elif property == 'redundancy':
          % if 'Erasure Codes' in value:
            Erasure codes consume less storage capacity than replication while provoding the same durability and availability guarantees. However, reconstructing a missing piece takes more time with erasure codes. <a class="open-popup" href="#redundancy">Read more.</a>
          % elif value == 'Replication':
            Replication is a simple redundancy mechanism that consumes more storage capacity than erasure codes but requires less time to reconstruct a missing piece.
          % else:
            Redundancy mechanisms ensure the availability and durability of the files stored in the storage infrastructure. <a class="open-popup" href="#redundancy">Read more.</a>
          % endif

        % elif property == 'security':
          % if value == 'In-Transit':
            Every communication is encrypted (in transit) but data, once stored, is not (at rest). <a class="open-popup" href="#security">Read more.</a>
          % elif value == 'In Transit & At-Rest':
            Every communication is encrypted (in transit) while every piece of data is also encrypted on disk (at rest). <a class="open-popup" href="#security">Read more.</a>
          % else:
            Communications are not encrypted (in transit) and pieces of data are stored in plain text i.e not encrypted on disk (at-rest). <a class="open-popup" href="#security">Read more.</a>
          % endif

        % elif property == 'interoperability':
          The ways a user or program can interact with a storage system; either through specific desktop/mobile applications or standard protocols.
          <a class="open-popup" href="#interoperability">Read more.</a>

        % elif property == 'interface':
          % if value == 'File Synchronization':
            File synchronization solutions clone all the files from a master copy onto one's local device, hence consuming some of the device's local storage capacity. <a class="open-popup" href="#interface">Read more.</a>
          % else:
            File systems are better suited for accessing storage infrastructure with large amounts of data since, unlike file synchronization, the files do not need to be downloaded locally first but can be accessed on-demand. <a class="open-popup" href="#interface">Read more.</a>
          % endif

        % elif property == 'fault_tolerance':
          The ability to maintain a storage system operational depends on algorithms that need to adapt depending on the nature of the environment. <a class="open-popup" href="#fault_tolerance">Read more.</a>

        % elif property == 'environment':
          % if value == 'Worldwide':
            Worldwide environments can be worrying for businesses that need to control where and how their files are stored. <a class="open-popup" href="#environment">Read more.</a>
          % else:
            A controlled environment is a set of servers and clients that are under the control of a single entity e.g a company. <a class="open-popup" href="#environment">Read more.</a>
          %endif

        % elif property == 'model':
          % if value == 'Centralized':
            Centralized systems store both the data and metadata on a single server. The reliability of the whole infrastructure depends on a single server. <a class="open-popup" href="#model">Read more.</a>
          % elif value == 'Distributed':
            Distributed storage systems distribute the data between a set of storage servers while some specific metadata server control the overall infrastructure, possibly acting as single points of failure and/or bottlenecks. <a class="open-popup" href="#model">Read more.</a>
          % else:
            Decentralized systems distribute both the data and metadata so as to remove any potential single point of failure or bottleneck. <a class="open-popup" href="#model">Read more.</a>
          %endif
        % endif
        </p>
        <div class="competitor">
          <span class="value ${'unknown' if 'Unknown' in value or value == '' else ''}">
            <%
            platforms = None

            if "Applications" in value:
              try:
                arr = value.split('(')
                value = arr[0]
                platforms = arr[1]
              except IndexError:
                pass

            elif value == '':
              value = 'Not Applicable'
            %>

            ${value}
          </span>
          % if property == 'interoperability' and platforms:
            <span class="platforms">(${platforms}</span>
          % endif
        </div>
        <div class="infinit">
          <img src="${url('images/logos/infinit.png')}" alt="${competitor['name']} logo">
          <span>
            <%
              value_infinit = value_infinit.capitalize() if len(value_infinit.split()) == 1 else value_infinit
            %>

            <% if "Applications" in value_infinit:
              try:
                arr = value_infinit.split('(')
                value_infinit = arr[0]
                platforms_infinit = arr[1]
              except AttributeError:
                pass
            %>

            ${value_infinit}

            % if property == 'interoperability' and platforms_infinit:
              <span class="platforms">(${platforms_infinit}</span>
            % endif
          </span>
        </div>
      </div>
    % endfor
    </div>

    % if 'similar_to' in competitor:
      <h3 class="links">Similar To</h3>
      <ul class="similar_to">
        % for value in competitor['similar_to']:
          <li><img src="${url('images/logos/' + value + '.png')}"><a href="${value}">${json[value]['name']}</a></li>
        % endfor
      </ul><br>
    % endif

    % if 'links' in competitor:
      <h3 class="links">Links</h3>
      <ul>
        % for property, value in competitor['links'].items():
          <li><a target="_blank" href="${value}">${property.capitalize()}</a></li>
        % endfor
      </ul>
    % endif

    <div class="popup mfp-hide" id="object-file">
      <p class="title">Architecture</p>
      <p><strong><a href="https://en.wikipedia.org/wiki/Object_storage" target="_blank">Object storage</a></strong> architecture manage data as objects. Object storage is mostly used to store application-specific, movies in the case of <em>Netflix</em> for example.</p>
      <p><strong><a href="https://en.wikipedia.org/wiki/File_system" target="_blank">File storage</a></strong> solutions represent data in files organized in folders and subfolders. This organization of information into a <a href="https://en.wikipedia.org/wiki/Directory_structure" target="_blank">hierarchical view</a> is perfectly adapted for humans to store and collaborate. In addition, file systems often provide an <a href="https://en.wikipedia.org/wiki/Computer_access_control" target="_blank">access control</a> mechanism, in particular in multi-user environments, to control which files/directories can be seen/edited by other users/groups.</p>
      <p>Another architecture exists, known as <strong><a href="https://en.wikipedia.org/wiki/Block_(data_storage)" target="_blank">block storage</a></strong>, which manages data as blocks within sectors and tracks i.e very much like a raw hard disk drive.</p>
    </div>

    <div class="popup mfp-hide" id="scalability">
      <p class="title">Scalability</p>
      <p>Some systems <strong>do not allow for the overall storage capacity to evolve</strong> over time. The ones that do are said to be <a href="https://en.wikipedia.org/wiki/Scalability" target="_blank">scalable</a>. Scalable storage systems could be further categorized into those that can scale without any interruption of service and those that require shutting down the system. In reality, the vast majority of existing scalable systems can scale dynamically i.e without requiring shutting down the service.</p>

      <p>There exists two types of systems when it comes to scalability. The first category contains systems that can <strong>scale over homogeneous resources</strong> such as local disks, network-attached storage resources etc; resources that are under the control of the infrastructure's administrator.</p>

      <p>Systems capable of <strong>heterogeneous scalability</strong> are able to integrate additional storage capacity from resources and providers of different nature being in the cloud, through an API or else. Heterogeneous-scalable storage systems often rely on <a class="open-popup" href="#security">at-rest encryption</a> and <a class="open-popup" href="#fault_tolerance">Byzantine consensus algorithms</a> to cope with potentially malicious behaviors since the integrated storage resources are often not under the control of the infrastructure's administrator.</p>
      <p>Note that should such a system provide these mechanisms, it would exhibit most of the prerequisites to be deployed in a <a class="open-popup" href="#environment">worldwide environment</a>.</p>
    </div>

    <div class="popup mfp-hide" id="redundancy">
      <p class="title">Redundancy</p>
      <p>Many storage systems provide <strong>no <a href="https://en.wikipedia.org/wiki/Data_redundancy" target="_blank">redundancy</a> mechanism</strong> and therefore cannot ensure the <a href="https://en.wikipedia.org/wiki/Data_redundancy" target="_blank">reliability</a> of the data they store. As a result, should a <a class="open-popup" href="#fault_tolerance">server fail</a> in such a system, some of (and possibly all) the data would be made <a href="https://en.wikipedia.org/wiki/Downtime" target="_blank">unavailable</a> &horbar; temporarily or permanently depending on the nature of the failure.</p>

      <p>Reliability &horbar; represented by both <a href="https://en.wikipedia.org/wiki/Durability_(database_systems)" target="_blank">durability</a> (data stored remain in the system) and <a href="https://en.wikipedia.org/wiki/Data_availability" target="_blank">availability</a> (data is always accessible) &horbar; implies that a system provides some sort of a redundancy mechanism. There are basically two categories of redundancy algorithms: replication and erasure codes (which are error-correcting codes).</p>

      <h3>Replication</h3>
      <p><a href="https://en.wikipedia.org/wiki/Replication_(computing)" target="_blank"><strong>Replication</strong></a> consists in creating exact copies of a data item to ensure that, if a copy goes missing (following a server failure, corruption or else), the system can keep operating with the remaining copies.</p>
      <p>There are many ways to decompose the original file, distribute it and replicate it between the storage media (server, disk etc.) in order to benefit from different properties. The <a href="https://en.wikipedia.org/wiki/RAID" target="_blank">RAID</a> technology for instance provides several schemas, or RAID levels, to achieve different balance between reliability, availability, performance and capacity.</p>

      <h3>Erasure Codes</h3>
      <p><a href="https://en.wikipedia.org/wiki/Erasure_code" target="_blank"><strong>Erasure codes</strong></a>, such as <a href="https://en.wikipedia.org/wiki/Reed%E2%80%93Solomon_error_correction" target="_blank">Reed-Solomon</a>, do not create raw copies of a data item as replication does. Instead, error-correcting codes transform a data block of <em>k</em> symbols into a longer of <em>n</em> symbols such that the original data block can be recovered from a subset of the <em>n</em> symbols.</p>
      <p>Erasure codes are more interesting than replication when it comes to storage consumption since less storage capacity is required to achieve the same durability and availability. However, the process of recreating a lost piece (replica or symbol) is cheaper with replication as an erasure-code-based system would need to reconstitute the original block by fetching <em>n</em> symbols before computing the missing symbol and restoring it.</p>

      <br>
      <p class="note">Note that such redundancy mechanisms differ from <a href="https://en.wikipedia.org/wiki/Backup" target="_blank">backups</a>. Should a server fail, redundancy mechanisms ensure that clients can continue accessing the data transparently (property known as availability). Backups however require restoring a snapshot before the data becomes accessible again, process which can take several days during which the whole system is non-operational.</p>
    </div>

    <div class="popup mfp-hide" id="security">
      <p class="title">Security</p>
      <p>Most storage systems <strong>do not encrypt data</strong> <a href="https://en.wikipedia.org/wiki/Data_in_transit" target="_blank">in transit</a> (between clients and servers) nor <a href="https://en.wikipedia.org/wiki/Data_at_rest" target="_blank">at rest</a> (once stored on a server) because the environment allows it i.e the clients and servers are located in a trusted network such as a company's.</p>

      <p>Large-scale <a class="open-popup" href="#environment">worldwide environments</a> require a storage solution that both encrypts <strong>in transit and at rest</strong> so that a block of data cannot be decrypted by a potentially malicious storage server. Such at-rest encryption mechanisms are necessary because worldwide environments are usually considered untrustworthy since composed of many devices under the control of unknown entities.</p>

      <p>In some cases, for instance cloud-based storage services, only the communications (<strong>in transit</strong>) are encrypted while the blocks are stored in plain form on the servers. This is required for those solutions to be able to offer users with a <a class="open-popup" href="#interface">Web-based interface</a> to browse and manipulate their files online.</p>
    </div>

    <div class="popup mfp-hide" id="interoperability">
      <p class="title">Interoperability</p>
      <p>File-based storage systems need to take into account the multitude of platforms in use today, both mobile and desktop, for human end-users to be able to manipulate their files through well designed <strong>applications</strong>.</p>

      <p>Object-based and block-based systems tend to comply with standard <strong>protocols</strong> to interact with the system, from <a href="https://en.wikipedia.org/wiki/Server_Message_Block" target="_blank">SMB</a> to specific <a href="https://en.wikipedia.org/wiki/Web_API" target="_blank">HTTP-based APIs</a> for cloud-based solutions. Likewise, many file-based storage systems integrate with existing protocols to ease the process of deploying clients on thousands of machines e.g <a href="https://en.wikipedia.org/wiki/Network_File_System" target="_blank">NFS</a>. Noteworthy is that many operating systems (Windows, MacOS X etc.) and mobile applications allow for the connection through such protocols to access remote file systems.</p>
    </div>

    <div class="popup mfp-hide" id="interface">
      <p class="title">Interface</p>
      <p>A storage solution, in particular file-based, can be accessed in different ways. Every interface has its benefits and disadvantages that are summarized next.</p>

      <h3>File Synchronization</h3>
      <p><a href="https://en.wikipedia.org/wiki/File_synchronization" target="_blank"><strong>Synchronization</strong> technologies</a> clone all the files from a master copy (in the cloud for instance) to one's local device. This process has the advantage of keeping all the files local at any time, ensuring access even in worst case scenarios e.g when completely disconnected from the Internet.</p>
      <p>Unfortunately, such a technology also has its drawbacks, mainly to consume the local storage capacity of one's device. This becomes particularly problematic as the amount of data stored increases and exceeds the storage capacity available locally.</p>
      <p>As a result, file synchronization solutions tend to provide a mechanism &horbar; named <em>Selective Sync</em> for Dropbox &horbar; for the user to select which files and folders should not be cloned locally, rendering those inaccessible from this device.</p>

      <h3>File System</h3>
      <p>File synchronization is performed by a small program running in the background (i.e a daemon) that monitores changes between the master and local copies. <a href="https://en.wikipedia.org/wiki/POSIX" target="_blank">POSIX</a>-compliant <a href="https://en.wikipedia.org/wiki/File_system" target="_blank"><strong>file systems</strong></a> however is a low-level layer that emulates a hard disk drive. As such, file systems can capture low-level requests from applications and users such as reading and writing data from/to a file, adding an entry to a directory and so forth.</p>
      <p>File systems are better suited when users need to access large amount of data without having to download everything locally since everything can be retrieved on-demand i.e <a href="https://en.wikipedia.org/wiki/Streaming_media" target="_blank">streamed</a>. The limitation of file systems lies in the need for additional mechanisms to allow users to access information when offline e.g <a href="https://en.wikipedia.org/wiki/Cache_(computing)" target="_blank">caching</a>.</p>

      <h3>Desktop/Web Application</h3>
      <p>Some file storage solutions provide a <a href="https://en.wikipedia.org/wiki/Web_application" target="_blank">Web</a> or specific <a href="https://en.wikipedia.org/wiki/Graphical_user_interface" target="_blank">desktop graphical user interface</a> to access and manage files.</p>
      <p><strong>Web</strong> interfaces are appreciated because users do not need to install an application on their computer. However, the user may lose in productivity because some <a href="https://en.wikipedia.org/wiki/File_format" target="_blank">file formats</a> may not be supported for online edition e.g <em>Photoshop</em>, <em>Catia</em> etc.</p>
      <p><strong>Desktop</strong> applications bring the worst of both worlds as users need to learn a new way to manipulate their files, as for a Web interface, while requiring an application to be installed locally; not to mention that very few file formats are usually supported.</p>

      <br>
      <p class="note">Most enterprise solutions provide a file system because such an interface is well-suited to environments with a lot of data (no local storage consumption) while not degrading productivity by forcing users to learn to manipulate their files through a new and specific application or constraining them regarding the support file formats.</p>

      <h3>API/SDK</h3>
      <p>Object storage solutions, since mostly accessed by applitions, generally provide an <a href="https://en.wikipedia.org/wiki/Web_API" target="_blank"><strong>API</strong></a> or <a href="https://en.wikipedia.org/wiki/Software_development_kit" target="_blank"><strong>SDK</strong></a>.</p>
    </div>

    <div class="popup mfp-hide" id="fault_tolerance">
      <p class="title">Fault Tolerance</p>
      <p>The capacity to maintain a storage system operational in the event of failure is referred to as <a href="https://en.wikipedia.org/wiki/Fault_tolerance" target="_blank">fault tolerance</a>.</p>
      <p>While some systems provide <strong>no fault tolerance mechanism</strong>, most do. Depending on the nature of the resources composing a storage infrastructure, a system will need a different algorithms to detect potential failures: <a href="https://en.wikipedia.org/wiki/Software_bug" target="_blank">bug</a>, <a href="https://en.wikipedia.org/wiki/Crash_(computing)" target="_blank">crash</a> (temporary or permanent) or even <a href="https://en.wikipedia.org/wiki/Hacker_(computer_security)" target="_blank">malicious behavior</a>.</p>

      <p>The distributed storage systems that do offer some means of redundancy, often integrate a mechanism that monitors storage servers to detect potential failures. Note however that such <strong>standard fault tolerance</strong> algorithms assume that the servers will always follow the system's protocol because distributed storage solutions are generally deployed within a <a class="open-popup" href="#environment">controlled environment</a> e.g a company's network.</p>

      <p>If some of the storage resources composing the infrastructure are not under the control of the administrator, the assumption cannot hold and the fault tolerance algorithm must be adapted to tolerate failures known as <a href="https://en.wikipedia.org/wiki/Hacker_(computer_security)" target="_blank"><strong>Byzantine</strong></a> i.e potentially malicous behaviors.</p>

      <p>Finally, some systems &horbar; in particular distributed file storage without a redundancy mechanism &horbar; may be <strong>partially fault tolerant</strong>, allowing users to access the files that remain available while returning an error should the file be located on the server that failed.</p>
    </div>

    <div class="popup mfp-hide" id="environment">
      <p class="title">Environment</p>
      <p>The environment in which is deployed a storage system radically changes the constrains it must take into account for designing <a class="open-popup" href="#security">security</a>, reliability (<a class="open-popup" href="#redundancy">redundancy</a> & <a class="open-popup" href="#fault_tolerance">fault tolerance</a>) and <a class="open-popup" href="#scalability">scalability</a> mechanisms.</p>

      <h3>Controlled</h3>
      <p>The vast majority of storage solutions have been designed to operate in a <strong>controlled</strong> environment i.e a set of servers and clients that are under the control of a single entity e.g a company.</p>
      <p>By evolving in a controlled environment, such solutions can better apprehend the infrastructure variations (<a href="https://en.wikipedia.org/wiki/Latency_(engineering)" target="_blank">latency</a>, <a href="https://en.wikipedia.org/wiki/Uptime" target="_blank">uptime</a> etc.) in order to optimize the protocols and algortihms. As an example, the latency in a local area network will not be a constraint while the data will not need to be encrypted at rest since hosted on trusted servers.</p>

      <h3>Worldwide</h3>
      <p>Storage solutions that evolve in a globally distributed environment, also known as <strong>worldwide</strong>, face unique challenges regarding latency, trust etc.</p>
      <p>Indeed, in such environments, the data is spread across a large number of computing devices that are under the control of different entities. As such, the blocks composing the file of a user may end up being stored on computers located in different countries e.g US, China, Germany etc.</p>
      <p>A user may not feel comfortable knowing that his/her files are stored on someone else's computer, even though the blocks are encrypted. This is particularly worrying for businesses that could be interested in the technology but need to control where and how their files are actually stored.</p>

      <br>
      <p class="note">Note that some solutions provide tools allowing developers to create their own storage infrastructure: <a href="${route('doc_comparisons')}tahoe-lafs">Tahoe-LAFS</a>, <a href="${route('doc_comparisons')}ipfs">IPFS</a> and <strong>Infinit</strong>. As such, a developer can decide which computers are involved in the infrastructure while defining scalability policies, allowing or not untrustworthy nodes to join the network etc. As a result, such solutions can be deployed in both controlled and worldwide environments.</p>
    </div>

    <div class="popup mfp-hide" id="model">
      <p class="title">Model</p>
      <p>The way the different servers and clients are arranged in a storage system can have a drastic impact on the overall infrastructure's performance, <a class="open-popup" href="#scalability">scalability</a> and reliability (<a class="open-popup" href="#redundancy">redundancy</a> & <a class="open-popup" href="#fault_tolerance">fault tolerance</a>).

      <h3>Centralized</h3>
      <p><strong>Centralized storage systems</strong> store both the data and metadata on a single server. Even though such models are interesting for their simplicity, the <a href="https://en.wikipedia.org/wiki/Data_availability" target="_blank">availability</a> and <a href="https://en.wikipedia.org/wiki/Durability_(database_systems)" target="_blank">durability</a> of the whole infrastructure depends upon a single server.</p>

      <h3>Distributed</h3>
      <p>Adding more servers would increase complexity to the overall infrastructure but would allow it to support a larger number of clients. Such storage systems distribute the requests and data between the different storage servers so as to increase <a href="https://en.wikipedia.org/wiki/Scalability" target="_blank">scalability</a> and <a href="https://en.wikipedia.org/wiki/Resilience_(network)" target="_blank">resilience</a>. <strong>Distributed storage system</strong> however have the particularity of storing the metadata on specific servers, sometimes referred to as <em>metadata servers</em> or <em>master servers</em> (as opposed to <em>data servers</em> and <em>slave servers</em>).</p>
      <p>For some large-scale infrastructure, distributed systems are limited by the capacity of <a href="https://en.wikipedia.org/wiki/Metadata" target="_blank">metadata</a> servers. Indeed, should there be too many clients' requests, a metadata server could fail. A <a href="https://en.wikipedia.org/wiki/Load_balancing_(computing)" target="_blank">load balancing</a> mechanism being often provided, following such a failure the clients will start re-routing their requests to the other metadata servers, implicitely increasing the load on those, possibly leading to a <a href="https://en.wikipedia.org/wiki/Cascading_failure" target="_blank">cascading failure</a>.</p>

      <h3>Decentralized</h3>
      <p><strong>Decentralized systems</strong> are designed for extreme scalability, taking into account that nodes will fail eventually.</p>
      <p>As a result, such systems distribute on the storage servers both the data and metadata so that no server performs a specific task. There is no <em>metadata server</em> that could act as a <a href="https://en.wikipedia.org/wiki/Single_point_of_failure" target="_blank">single point of failure</a> or <a href="https://en.wikipedia.org/wiki/Bottleneck_(software)" target="_blank">bottleneck</a>.</p>
    </div>

  </section>

</%block>
