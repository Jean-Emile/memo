<%inherit file="/base.html"/>

<%block name="content">

  <%include file='menu.html'/>

  <section class="doc ${competitor_name}">
    <h1>${competitor['name']}</h1>
    <p class="description">
      ${competitor['description']}
      % if 'wikipedia' in competitor['links']:
        <em><a target="_blank" href="${competitor['links']['wikipedia']}"><img src="${url('images/icons/external-link.png')}" alt=""> see more</a></em>
      % endif
    </p>

    <table class="properties ${'compared' if show_comparison else ''}">
    <%
      properties = [None]*10

      for property, value in competitor['properties'].items():
        if property == 'model':
          properties[0] = ['model', value]
        elif property == 'logic':
          properties[1] = ['logic', value]
        elif property == 'interface':
          properties[2] = ['interface', value]
        elif property == 'environment':
          properties[3] = ['environment', value]
        elif property == 'scalability':
          properties[4] = ['scalability', value]
        elif property == 'redundancy':
          properties[5] = ['redundancy', value]
        elif property == 'fault-tolerance':
          properties[6] = ['fault-tolerance', value]
        elif property == 'security':
          properties[7] = ['security', value]
        elif property == 'open-source':
          properties[8] = ['open-source', value]
        elif property == 'pricing':
          properties[9] = ['pricing', value]
    %>

    <tr>
      <th></th>
      <th class="competitor"><img class="competitor big" src="${url('images/logos/' + competitor_name + '.png')}" alt="${competitor['name']} logo"></th>
      <th class="infinit"><img src="${url('images/logos/infinit.png')}" alt="Infinit logo"></th>
    </tr>

    % for property, value in properties:
      <%
        value_infinit = infinit['properties'][property]
        if value == value_infinit:
          is_similar = True
        else:
          is_similar = False
      %>

      <tr class="property ${'same' if is_similar else 'different'} ${property}">

        <td class="desc">
          <img class="" src="${url('images/icons/' + property + '.png')}" alt="${property}">
          <h2 id="${competitor_name}_${property}">${property.replace('-', ' ').title()}</h2>

          % if property == 'model':
            <a class="open-popup" href="#model">?</a>
            <p class="note">The model impacts the system's ability to scale while maintaining an efficient, secure and reliable service.</p>

          % elif property == 'logic':
            <a class="open-popup" href="#logic">?</a>
            <p class="note">The logic allows for applications to benefit from more advanced functionalities than just a key-value store.</p>

          % elif property == 'interface':
            <a class="open-popup" href="#interface">?</a>
            <p class="note">An interface allows an application or use to access a storage logic through a standard protocol, GUI or else.</p>

          % elif property == 'environment':
            <a class="open-popup" href="#environment">?</a>
            <p class="note">A storage solution can be deployed over an environment which is or not under total control.</p>

          % elif property == 'scalability':
            <a class="open-popup" href="#scalability">?</a>
            <p class="note">The ability to scale out heteroegeneously allows for more diverse storage infrastructure.</p>

          % elif property == 'redundancy':
            <a class="open-popup" href="#redundancy">?</a>
            <p class="note">Different redundancy mechanisms can be implemented, each with its tradeoffs.</p>

          % elif property == 'fault-tolerance':
            <a class="open-popup" href="#fault-tolerance">?</a>
            <p class="note">The ability to maintain a storage system operational requires being able to cope with "unexpected" behaviors.</p>

          % elif property == 'security':
            <a class="open-popup" href="#security">?</a>
            <p class="note">A secure storage system must be designed with encrypted communication, access control etc. from the ground up.</p>

          % elif property == 'open-source':
            <br><p class="note">Storage products and projects may or may not have their source code available to the public.</p>

          % elif property == 'pricing':
            <br><p class="note">Storage solutions differ in their pricing model from licenses, freemium and more.</p>

          % endif
          </p>
        </td>
        <td class="competitor" ${'colspan="2"' if is_similar else ''}>
          % if value:
            % for item in value:
              <span class="value">${item}</span>
            % endfor
          % else:
            <span class="value unknown">?</span>
          % endif
        </td>
        % if not is_similar:
          % if value_infinit:
            <td class="infinit">
              % for item in value_infinit:
                <span class="value">${item}</span>
              % endfor
            </td>
          % else:
            <span class="value unknown">?</span>
          % endif
        % endif
      </tr>
    % endfor
    </table>

    <div class="popup mfp-hide" id="model">
      <p class="title">Model</p>
      <section class="doc">
      <p>The way the different servers and clients are arranged in a storage system can have a drastic impact on the overall infrastructure's performance, <a class="open-popup" href="#scalability">scalability</a> and reliability (<a class="open-popup" href="#redundancy">redundancy</a> & <a class="open-popup" href="#fault-tolerance">fault tolerance</a>).</p>

      <h3>Centralized</h3>
      <p><strong>Centralized storage systems</strong> store both the data and metadata on a single server. Even though such models are interesting for their simplicity, the <a href="https://en.wikipedia.org/wiki/Data_availability" target="_blank">availability</a> and <a href="https://en.wikipedia.org/wiki/Durability_(database_systems)" target="_blank">durability</a> of the whole infrastructure depends upon a single server.</p>

      <h3>Distributed</h3>
      <p>Adding more servers would increase complexity to the overall infrastructure but would allow it to support a larger number of clients as well as increase its total storage capacity. Such storage systems distribute the data blocks between the different storage servers effectively rendering the system <a href="https://en.wikipedia.org/wiki/Scalability" target="_blank">scalable</a> and <a href="https://en.wikipedia.org/wiki/Resilience_(network)" target="_blank">resilient</a>.</p>
      <p><strong>Distributed storage systems</strong> handle such elasticity by introducing more specific and privileged <em>master servers</em>, also known as <em>managers</em>, to <a href="https://en.wikipedia.org/wiki/Master/slave_(technology)" target="_blank">orchestrate</a> the whole system, from routing requests to the other servers, known as <em>slave nodes</em> or <em>workers</em>, managing metadata and more.</p>

      <h3>Decentralized</h3>
      <p>For some systems, the distributed model, also known as manager/worker model, is limited by the capacity of <a href="https://en.wikipedia.org/wiki/Metadata" target="_blank">metadata</a> servers to process client requests, handle worker nodes and achieve consensus with the other managers. With too many requests to process, the system could suffer <a href="https://en.wikipedia.org/wiki/Bottleneck_(software)" target="_blank">bottlenecks</a>, <a href="https://en.wikipedia.org/wiki/Single_point_of_failure" target="_blank">single point of failures</a>, performance degradations, <a href="https://en.wikipedia.org/wiki/Cascading_failure" target="_blank">cascading effects</a> and more, not to mention that the managers cannot be scaled out as easily as the workers, limiting further the system's scalability and performance.
      <p><strong>Decentralized systems</strong> are designed for extreme scalability by distributing the data, metadata and requests between all the nodes that have the particularity of being equally unprivileged. By doing away with <em>managers</em>, such systems exhibit better performance (natural distribution), scalability (per-block quorums), resilience (no critical node) and security (reduced surface of attack).
      </section>
    </div>

    <div class="popup mfp-hide" id="logic">
      <p class="title">Logic</p>
      <section class="doc">
      <p><strong><a href="https://en.wikipedia.org/wiki/Object_storage" target="_blank">Object storage</a></strong> systems manage data as objects or <em>blobs</em>. Object storage is mostly used for storing application-specific, movies in the case of <em>Netflix</em>, file content in the case of <em>Dropbox</em>, etc.</p>
      <p><strong><a href="https://en.wikipedia.org/wiki/File_system" target="_blank">File storage</a></strong> solutions represent data in files organized in folders and subfolders. This organization of information into a <a href="https://en.wikipedia.org/wiki/Directory_structure" target="_blank">hierarchical view</a> is perfectly adapted for humans to store and collaborate. In addition, file systems often provide an <a href="https://en.wikipedia.org/wiki/Computer_access_control" target="_blank">access control</a> mechanism, in particular in multi-user environments, to control which files/directories can be seen/edited by other users/groups.</p>
      <p>Another storage logic exists, known as <strong><a href="https://en.wikipedia.org/wiki/Block_(data_storage)" target="_blank">block storage</a></strong>, which manages data as blocks within a virtual raw partition i.e very much as for raw hard disk drive. Note that such block storage logics are made accessible through a <a href="https://en.wikipedia.org/wiki/Device_file#BLOCKDEV" target="_blank">virtual block device</a> which needs to be formatted in a local file system, <em>ext4</em> for instance. Such block storage logics have the particularity of being usually only accessible from a single node while a distributed file system handles concurrent accesses from multiple client nodes.</p>
      </section>
    </div>

    <div class="popup mfp-hide" id="interface">
      <p class="title">Interface</p>
      <section class="doc">
      <p>A storage solution may provide a set of interfaces for accessing the different storage logics it offers.</p>

      <h3>Block & File Storage</h3>

      <p>Block and file storage logics are usually accessed through standard low-level <strong>protocols</strong> such as <em><a href="https://en.wikipedia.org/wiki/Network_block_device" target="_blank">network block device (NBD)</a></em>, <em><a href="https://en.wikipedia.org/wiki/ISCSI" target="_blank">iSCSI</a></em>, etc. and <em><a href="https://en.wikipedia.org/wiki/Filesystem_in_Userspace" target="_blank">FUSE/OSX FUSE</a>/Dokan</em>, <em><a href="https://en.wikipedia.org/wiki/Network_File_System" target="_blank">network file system (NFS)</a></em> etc., respectively.</p>

      <h3>Object Storage</h3>

      <p>An object storage logic is however accessed through a more modern HTTP-based <strong>API</strong> such as <em><a href="https://en.wikipedia.org/wiki/Amazon_S3" target="_blank">Amazon S3</a></em>, <em>Google Cloud Storage (GCS)</em> or <em><a href="https://en.wikipedia.org/wiki/OpenStack#Object_Storage_.28Swift.29" target="_blank">OpenStack Swift</a></em>.</p>

      <h3>Other</h3>

      <p>Other interfaces include <strong>file synchronization</strong> as used by popular cloud file storage services likes <em>Dropbox</em>, <em>Box</em>, <em>Google Drive</em> etc.<p>
      <p>In addition to existing interfaces, many products, in particular consumer oriented, provide <strong><a href="https://en.wikipedia.org/wiki/Graphical_user_interface" target="_blank">graphical user interfaces</a> (GUI)</strong> for desktop, mobile and Web while other also offer specific <strong><a href="https://en.wikipedia.org/wiki/Application_programming_interface" target="_blank">application programming interfaces</a> (API)</strong> or <a href="https://en.wikipedia.org/wiki/Software_development_kit" target="_blank"><strong>software development kits (SDK)</strong></a>.</p>
      </section>
    </div>

    <div class="popup mfp-hide" id="environment">
      <p class="title">Environment</p>
      <section class="doc">
      <p>The environment in which is deployed a storage system radically changes the constrains it must take into account when it comes to <a class="open-popup" href="#security">security</a>, reliability (<a class="open-popup" href="#redundancy">redundancy</a> & <a class="open-popup" href="#fault-tolerance">fault tolerance</a>) and <a class="open-popup" href="#scalability">scalability</a> mechanisms.</p>

      <h3>Controlled</h3>
      <p>The vast majority of storage solutions have been designed to operate in a <strong>controlled</strong> environment i.e a set of servers and clients that are under the control of a single entity e.g a company.</p>
      <p>By evolving in a controlled environment, such solutions can better apprehend the infrastructure variations (<a href="https://en.wikipedia.org/wiki/Latency_(engineering)" target="_blank">latency</a>, <a href="https://en.wikipedia.org/wiki/Uptime" target="_blank">uptime</a> etc.) in order to optimize the protocols and algortihms.</p>
      <p>As an example, the latency in a local area network will not be a constraint while the data may not need to be encrypted at rest since hosted on trusted servers.</p>

      <h3>Uncontrolled</h3>
      <p>Storage solutions that can be deployed over a cluster of untrustworthy nodes are known to evolve in <strong>uncontrolled</strong> environments and as such face unique challenges when it comes to latency, security etc.</p>
      <p>Indeed, in such environments, the data is spread across a large number of computing devices that are under the control of different entities. As such, the data blocks stored by a user may end up on computers located in different countries (e.g US, China, Germany etc.) and controlled by a potentially malicious user.</p>
      <p>A user may not feel comfortable knowing that his/her files are stored on someone else's computer, even though the blocks are encrypted. This is particularly worrying for businesses that could be interested in the technology but need to control where and how data is actually stored.</p>

      <br>
      <p class="note">Note that some solutions provide tools allowing developers and operators to create their own storage infrastructure. With <a href="${route('doc_comparisons')}tahoe-lafs">Tahoe-LAFS</a> and <strong>Infinit</strong>, an operator can decide which computers are involved in the infrastructure while defining scalability policies, allowing (or not) for untrustworthy nodes to join the network. As a result, such solutions can be deployed in both controlled and uncontrolled environments.</p>
      </section>
    </div>

    <div class="popup mfp-hide" id="scalability">
      <p class="title">Scalability</p>
      <section class="doc">
      <p>Some systems <strong>do not allow for the overall storage capacity to evolve</strong> over time. The ones that do are said to be <a href="https://en.wikipedia.org/wiki/Scalability" target="_blank">scalable</a>. Scalable storage systems could be further categorized into those that can scale without any interruption of service and those that require shutting down the system. In reality, the vast majority of existing scalable systems can scale (to some extent) dynamically i.e without requiring shutting down the service.</p>

      <p>There exists two types of systems when it comes to scalability. The first category contains systems that can <strong>scale over homogeneous resources</strong> such as local disks, network-attached storage resources etc; resources that are under the control of the infrastructure's administrator (<em><a href="https://en.wikipedia.org/wiki/Direct-attached_storage" target="_blank">DAS</a></em>, <em><a href="https://en.wikipedia.org/wiki/Network-attached_storage" target="_blank">NAS</a></em>, <em><a href="https://en.wikipedia.org/wiki/Storage_area_network" target="_blank">SAN</a></em> etc.).</p>
      <p>Systems capable of <strong>heterogeneous scalability</strong> are able to integrate additional storage capacity from resources and providers of different nature leading to more complex deployment such as hybrid clouds, multi clouds etc.</p>

      <p>Heterogeneous-scalable storage systems may rely on <a class="open-popup" href="#security">at-rest encryption</a> to secure the data when stored through a storage provider with limited trust. Likewise, the most advanced storage systems can make use of a <a class="open-popup" href="#fault-tolerance">Byzantine consensus algorithm</a> to cope with potentially malicious behaviors since the servers are not under the administrator's control.</p>
      <p>Note that should such a system provide these mechanisms, it would exhibit most of the prerequisites to be deployed in a <a class="open-popup" href="#environment">uncontrolled environment</a>.</p>
      </section>
    </div>

    <div class="popup mfp-hide" id="redundancy">
      <p class="title">Redundancy</p>
      <section class="doc">
      <p>Many storage systems provide <strong>no <a href="https://en.wikipedia.org/wiki/Data_redundancy" target="_blank">redundancy</a> mechanism</strong> and therefore cannot ensure the <a href="https://en.wikipedia.org/wiki/Data_redundancy" target="_blank">reliability</a> of the data they store. As a result, should a <a class="open-popup" href="#fault-tolerance">server fail</a> in such a system, some of (and possibly all) the data would be made <a href="https://en.wikipedia.org/wiki/Downtime" target="_blank">unavailable</a> &horbar; temporarily or permanently depending on the nature of the failure.</p>

      <p>Reliability &horbar; represented by both <a href="https://en.wikipedia.org/wiki/Durability_(database_systems)" target="_blank">durability</a> (data stored remain in the system) and <a href="https://en.wikipedia.org/wiki/Data_availability" target="_blank">availability</a> (data is always accessible) &horbar; implies that a system provides some sort of a redundancy mechanism. There are basically two categories of redundancy algorithms: replication and erasure codes (which are error-correcting codes).</p>

      <h3>Replication</h3>
      <p><a href="https://en.wikipedia.org/wiki/Replication_(computing)" target="_blank"><strong>Replication</strong></a> consists in creating exact copies of a data item to ensure that, if a copy goes missing (following a server failure, corruption or else), the system can keep operating with the remaining copies.</p>
      <p>There are many ways to decompose the original data piece, distribute it and replicate it between the storage media (server, disk etc.) in order to benefit from different properties. The <a href="https://en.wikipedia.org/wiki/RAID" target="_blank">RAID</a> technology for instance provides several schemas, or RAID levels, to achieve different balance between reliability, availability, performance and capacity.</p>

      <h3>Erasure Codes</h3>
      <p><a href="https://en.wikipedia.org/wiki/Erasure_code" target="_blank"><strong>Erasure codes</strong></a>, such as <a href="https://en.wikipedia.org/wiki/Reed%E2%80%93Solomon_error_correction" target="_blank">Reed-Solomon</a>, do not create raw copies of a data item as replication does. Instead, error-correcting codes transform a data block of <em>k</em> symbols into a longer of <em>n</em> symbols such that the original data block can be recovered from a subset of the <em>n</em> symbols.</p>
      <p>Erasure codes are more interesting than replication when it comes to storage consumption since less storage capacity is required to achieve the same durability and availability. However, the process of writing is slower than with replication as more servers need to be contacted to host data symbols. Likewise, more computing power is required to reconstruct the original data from several pieces when accessing data, leading to more latency.</p>

      <br>

      <p>Erasure codes are more adapted to archiving while replication is often preferred for primary storage. Note however, than beyond 100TB of data, the gain in storage capacity achievable through erasure coding becomes interesting enough to be considered even for primary storage.</p>

      <br>
      <p class="note">Note that such redundancy mechanisms differ from <a href="https://en.wikipedia.org/wiki/Backup" target="_blank">backups</a>. Should a server fail, redundancy mechanisms ensure that clients can continue accessing the data transparently (property known as availability). Backups however require restoring a snapshot before the data becomes accessible again, process which can take several days during which the whole system is non-operational.</p>
      </section>
    </div>

    <div class="popup mfp-hide" id="fault-tolerance">
      <p class="title">Fault Tolerance</p>
      <section class="doc">
      <p>The capacity to maintain a storage system operational in the event of failures is referred to as <a href="https://en.wikipedia.org/wiki/Fault_tolerance" target="_blank">fault tolerance</a>.</p>
      <p>While some systems provide <strong>no fault tolerance mechanism</strong>, most storage products do. Depending on the nature of the resources composing a storage infrastructure, a system will need a different algorithms to detect and deal with potential failures: <a href="https://en.wikipedia.org/wiki/Software_bug" target="_blank">bug</a>, <a href="https://en.wikipedia.org/wiki/Crash_(computing)" target="_blank">crash</a> (temporary or permanent) and even <a href="https://en.wikipedia.org/wiki/Hacker_(computer_security)" target="_blank">malicious behavior</a>.</p>

      <p>The scale-out software-defined storage systems that do offer some means of redundancy, often integrate a mechanism that monitors storage servers to detect potential failures. Note however that such <strong>standard fault tolerance</strong> algorithms assume that the servers will always follow the system's protocol because distributed storage solutions are generally deployed within a <a class="open-popup" href="#environment">controlled environment</a> e.g a company's network.</p>

      <p>If some of the storage resources composing the infrastructure are not under the control of the administrator, the assumption cannot hold and the fault tolerance algorithm must be adapted to tolerate failures known as <a href="https://en.wikipedia.org/wiki/Byzantine_fault_tolerance" target="_blank">Byzantine</a> i.e potentially malicous behaviors.</p>

      <p>Finally, some systems &horbar; in particular distributed storage without a redundancy mechanism &horbar; may be <strong>partially fault tolerant</strong>. In such cases, a server failing may render a number of data pieces unavailable until those servers come back online or an administration operation is manually performed.</p>
      </section>
    </div>

    <div class="popup mfp-hide" id="security">
      <p class="title">Security</p>
      <section class="doc">
      <p>Most storage systems <strong>do not encrypt data</strong> <a href="https://en.wikipedia.org/wiki/Data_in_transit" target="_blank">in transit</a> (between clients and servers) nor <a href="https://en.wikipedia.org/wiki/Data_at_rest" target="_blank">at rest</a> (once stored on a server).</p>

      <p>Large-scale deployments in <a class="open-popup" href="#environment">uncontrolled environments</a> require a storage solution that both encrypts <strong>in transit and at rest</strong> so that a piece of data cannot be decrypted by a potentially malicious storage server. Such at-rest encryption mechanisms are necessary because uncontrolled environments are usually considered untrustworthy since composed of many devices under the control of unknown entities.</p>

      <p>In some cases, for instance cloud-based storage services, only the communications (<strong>in transit</strong>) are encrypted while the blocks are stored in plain form on the servers. Although this is required for those solutions to be able to offer users with a <a class="open-popup" href="#interface">Web-based interface</a> to browse and manipulate their data online, it is recommended to always encrypt data at rest, in particular on cloud storage services.</p>
      </section>
    </div>

</section>

</%block>
